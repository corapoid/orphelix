# 1.2 YAML Editor with GitHub Integration

## Overview
GitHub-based YAML editor that allows users to edit Kubernetes manifests stored in GitHub repositories, automatically create Pull Requests, and track pending changes.

## User Flow

```
1. User logs in with GitHub (OAuth)
2. User selects Kubernetes cluster (existing flow)
3. User navigates to Deployments list
4. User clicks on a deployment (e.g., "nginx-app")
5. On deployment details page: [Edit YAML] button
6. Modal opens with GitHub integration:
   - Auto-detect matching file in selected repo (AI/LLM matching)
   - Show file tree if multiple matches
   - Load YAML content in Monaco editor
7. User edits YAML with real-time validation
8. User clicks [Create Pull Request]
9. PR is created automatically
10. Modal shows PR link with [Open PR] and [Close] buttons
11. Badge appears on deployment list: "nginx-app [PR #123]"
12. User can merge PR directly from GitHub
```

## Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   GitHub OAuth      â”‚
â”‚   - Login flow      â”‚
â”‚   - Access token    â”‚
â”‚   - Repo selection  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               Deployment Details Page                    â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚   â”‚  nginx-app                    [PR #123]     â”‚       â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚       â”‚
â”‚   â”‚  â”‚  [Edit YAML]  button                â”‚    â”‚       â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚       â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â–¼ (opens modal)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            GitHub YAML Editor Modal                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ ðŸ” Auto-detected: k8s/production/nginx-app.yaml  â”‚  â”‚
â”‚  â”‚    or: Select file manually â–¼                    â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚                                                   â”‚  â”‚
â”‚  â”‚  Monaco Editor                                    â”‚  â”‚
â”‚  â”‚  - Syntax highlighting                            â”‚  â”‚
â”‚  â”‚  - YAML validation                                â”‚  â”‚
â”‚  â”‚  - Kubernetes schema validation                   â”‚  â”‚
â”‚  â”‚  - Kustomization detection                        â”‚  â”‚
â”‚  â”‚                                                   â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚  Tabs: [ Base ] [ Overlays ]  (if kustomization) â”‚  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”‚
â”‚  â”‚  [Cancel]  [Preview Diff]  [Create Pull Request] â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â–¼ (creates PR)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Pull Request Created                        â”‚
â”‚  âœ… PR #123 created successfully                         â”‚
â”‚  ðŸ“ https://github.com/user/repo/pull/123               â”‚
â”‚                                                          â”‚
â”‚  [Open PR in GitHub]  [Close]                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Implementation Plan

### Phase 1: GitHub OAuth Setup (4-6 hours)

#### 1.1 Install Dependencies
```bash
npm install next-auth@beta @auth/core @octokit/rest
npm install @ai-sdk/openai ai  # For LLM file matching
```

#### 1.2 Create GitHub OAuth App
- Documentation in README for users to create their own OAuth app
- Required scopes: `repo`, `read:user`, `user:email`
- Callback URL: `http://localhost:3000/api/auth/callback/github`

#### 1.3 Environment Variables
```env
# .env.local
GITHUB_CLIENT_ID=your_client_id
GITHUB_CLIENT_SECRET=your_client_secret
NEXTAUTH_SECRET=generate_random_secret
NEXTAUTH_URL=http://localhost:3000

# For LLM file matching (optional, falls back to pattern matching)
OPENAI_API_KEY=your_openai_key  # or use local Ollama
```

#### 1.4 NextAuth Configuration
**File**: `/lib/auth/github-auth.ts`
```typescript
import NextAuth from 'next-auth'
import GithubProvider from 'next-auth/providers/github'

export const { handlers, auth, signIn, signOut } = NextAuth({
  providers: [
    GithubProvider({
      clientId: process.env.GITHUB_CLIENT_ID!,
      clientSecret: process.env.GITHUB_CLIENT_SECRET!,
      authorization: {
        params: {
          scope: 'repo read:user user:email',
        },
      },
    }),
  ],
  callbacks: {
    async jwt({ token, account }) {
      if (account) {
        token.accessToken = account.access_token
      }
      return token
    },
    async session({ session, token }) {
      session.accessToken = token.accessToken as string
      return session
    },
  },
})
```

**File**: `/app/api/auth/[...nextauth]/route.ts`
```typescript
export { GET, POST } from '@/lib/auth/github-auth'
```

#### 1.5 Update Store for GitHub
**File**: `/lib/store.ts`
```typescript
interface GitHubState {
  selectedRepo: { owner: string; repo: string; branch: string } | null
  setSelectedRepo: (repo: { owner: string; repo: string; branch: string } | null) => void
  pendingPRs: Map<string, number> // deployment name -> PR number
  setPendingPR: (deployment: string, prNumber: number) => void
  removePendingPR: (deployment: string) => void
}

// Add to existing store
```

#### 1.6 Session Provider
**File**: `/app/providers.tsx` (update existing)
```typescript
import { SessionProvider } from 'next-auth/react'

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <SessionProvider>
      <QueryClientProvider client={queryClient}>
        {/* existing providers */}
        {children}
      </QueryClientProvider>
    </SessionProvider>
  )
}
```

**Tests**:
- `lib/auth/github-auth.test.ts` - Test OAuth configuration
- E2E: Login flow with Playwright

---

### Phase 2: GitHub API Client (6-8 hours)

#### 2.1 GitHub Client Library
**File**: `/lib/github/client.ts`
```typescript
import { Octokit } from '@octokit/rest'

export class GitHubClient {
  private octokit: Octokit

  constructor(accessToken: string) {
    this.octokit = new Octokit({ auth: accessToken })
  }

  // List user's repositories
  async listRepositories(): Promise<Array<{ owner: string; repo: string; fullName: string }>>

  // List YAML files in repository (recursive)
  async listYamlFiles(owner: string, repo: string, path: string = ''): Promise<YamlFile[]>

  // Get file content
  async getFileContent(owner: string, repo: string, path: string, ref: string = 'main'): Promise<{ content: string; sha: string }>

  // Detect kustomization.yaml
  async detectKustomization(owner: string, repo: string, dirPath: string): Promise<boolean>

  // Get kustomize structure (base + overlays)
  async getKustomizeStructure(owner: string, repo: string, basePath: string): Promise<KustomizeStructure>

  // Create branch
  async createBranch(owner: string, repo: string, baseBranch: string, newBranch: string): Promise<void>

  // Commit file
  async commitFile(owner: string, repo: string, branch: string, path: string, content: string, sha: string, message: string): Promise<void>

  // Create Pull Request
  async createPullRequest(owner: string, repo: string, title: string, head: string, base: string, body: string): Promise<{ number: number; url: string }>

  // List Pull Requests for file
  async getPullRequestsForFile(owner: string, repo: string, filePath: string): Promise<Array<{ number: number; title: string; state: string }>>

  // Check if PR is merged
  async isPullRequestMerged(owner: string, repo: string, prNumber: number): Promise<boolean>
}
```

#### 2.2 File Matching with LLM
**File**: `/lib/github/file-matcher.ts`
```typescript
import { generateText } from 'ai'
import { openai } from '@ai-sdk/openai'

export class FileMatcher {
  // Match deployment to YAML file using LLM
  async findMatchingFile(
    deployment: { name: string; namespace: string },
    yamlFiles: YamlFile[]
  ): Promise<YamlFile | null> {
    // Try pattern matching first (fast)
    const patternMatch = this.patternMatch(deployment, yamlFiles)
    if (patternMatch) return patternMatch

    // Fall back to LLM matching (slow but accurate)
    if (process.env.OPENAI_API_KEY) {
      return this.llmMatch(deployment, yamlFiles)
    }

    return null
  }

  private patternMatch(deployment: { name: string; namespace: string }, files: YamlFile[]): YamlFile | null {
    // Try exact name match
    const exactMatch = files.find(f => f.name.includes(deployment.name))
    if (exactMatch) return exactMatch

    // Try namespace/name pattern
    const namespaceMatch = files.find(f =>
      f.path.includes(deployment.namespace) && f.name.includes(deployment.name)
    )
    if (namespaceMatch) return namespaceMatch

    return null
  }

  private async llmMatch(deployment: { name: string; namespace: string }, files: YamlFile[]): Promise<YamlFile | null> {
    const prompt = `
Given a Kubernetes deployment:
- Name: ${deployment.name}
- Namespace: ${deployment.namespace}

Which of these YAML files is most likely the manifest for this deployment?

Files:
${files.map((f, i) => `${i + 1}. ${f.path}`).join('\n')}

Return only the number of the best match, or 0 if no good match.
    `.trim()

    const { text } = await generateText({
      model: openai('gpt-4o-mini'),
      prompt,
      maxTokens: 10,
    })

    const matchIndex = parseInt(text.trim(), 10) - 1
    if (matchIndex >= 0 && matchIndex < files.length) {
      return files[matchIndex]
    }

    return null
  }
}
```

#### 2.3 PR Cache System
**File**: `/lib/github/pr-cache.ts`
```typescript
interface CachedPR {
  deploymentName: string
  namespace: string
  prNumber: number
  prUrl: string
  filePath: string
  timestamp: number
}

export class PRCache {
  private static CACHE_KEY = 'kubevista_pending_prs'
  private static CACHE_TTL = 30 * 60 * 1000 // 30 minutes

  // Get cached PRs
  static getCachedPRs(): CachedPR[] {
    if (typeof window === 'undefined') return []

    const cached = localStorage.getItem(this.CACHE_KEY)
    if (!cached) return []

    const prs: CachedPR[] = JSON.parse(cached)
    const now = Date.now()

    // Filter out expired entries
    return prs.filter(pr => now - pr.timestamp < this.CACHE_TTL)
  }

  // Add PR to cache
  static cachePR(pr: Omit<CachedPR, 'timestamp'>) {
    const prs = this.getCachedPRs()
    prs.push({ ...pr, timestamp: Date.now() })
    localStorage.setItem(this.CACHE_KEY, JSON.stringify(prs))
  }

  // Remove PR from cache
  static removePR(deploymentName: string, namespace: string) {
    const prs = this.getCachedPRs()
    const filtered = prs.filter(
      pr => !(pr.deploymentName === deploymentName && pr.namespace === namespace)
    )
    localStorage.setItem(this.CACHE_KEY, JSON.stringify(filtered))
  }

  // Get PR for deployment
  static getPRForDeployment(deploymentName: string, namespace: string): CachedPR | null {
    const prs = this.getCachedPRs()
    return prs.find(pr => pr.deploymentName === deploymentName && pr.namespace === namespace) || null
  }
}
```

**Tests**:
- `lib/github/client.test.ts` - Mock Octokit calls
- `lib/github/file-matcher.test.ts` - Test pattern matching
- `lib/github/pr-cache.test.ts` - Test localStorage caching

---

### Phase 3: API Routes (4-6 hours)

#### 3.1 List Repositories
**File**: `/app/api/github/repos/route.ts`
```typescript
import { auth } from '@/lib/auth/github-auth'
import { GitHubClient } from '@/lib/github/client'

export async function GET() {
  const session = await auth()
  if (!session?.accessToken) {
    return Response.json({ error: 'Unauthorized' }, { status: 401 })
  }

  const github = new GitHubClient(session.accessToken)
  const repos = await github.listRepositories()

  return Response.json(repos)
}
```

#### 3.2 List YAML Files
**File**: `/app/api/github/files/route.ts`
```typescript
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url)
  const owner = searchParams.get('owner')
  const repo = searchParams.get('repo')

  // ... auth check
  // ... list YAML files recursively

  return Response.json(files)
}
```

#### 3.3 Get File Content
**File**: `/app/api/github/file/route.ts`
```typescript
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url)
  const owner = searchParams.get('owner')
  const repo = searchParams.get('repo')
  const path = searchParams.get('path')

  // ... auth check
  // ... get file content

  return Response.json({ content, sha })
}
```

#### 3.4 Match File for Deployment
**File**: `/app/api/github/match-file/route.ts`
```typescript
import { FileMatcher } from '@/lib/github/file-matcher'

export async function POST(request: Request) {
  const { deployment, yamlFiles } = await request.json()

  const matcher = new FileMatcher()
  const matchedFile = await matcher.findMatchingFile(deployment, yamlFiles)

  return Response.json({ matchedFile })
}
```

#### 3.5 Create Pull Request
**File**: `/app/api/github/create-pr/route.ts`
```typescript
export async function POST(request: Request) {
  const { owner, repo, filePath, content, deploymentName, namespace } = await request.json()

  // ... auth check

  const github = new GitHubClient(session.accessToken)

  // 1. Get current file
  const { sha } = await github.getFileContent(owner, repo, filePath)

  // 2. Create branch
  const branchName = `kubevista-${deploymentName}-${Date.now()}`
  await github.createBranch(owner, repo, 'main', branchName)

  // 3. Commit changes
  await github.commitFile(owner, repo, branchName, filePath, content, sha, `Update ${deploymentName} via KubeVista`)

  // 4. Create PR
  const pr = await github.createPullRequest(
    owner,
    repo,
    `Update ${deploymentName}`,
    branchName,
    'main',
    `Updated \`${filePath}\` via KubeVista\n\n**Deployment**: ${deploymentName}\n**Namespace**: ${namespace}`
  )

  // 5. Cache PR
  PRCache.cachePR({
    deploymentName,
    namespace,
    prNumber: pr.number,
    prUrl: pr.url,
    filePath,
  })

  return Response.json(pr)
}
```

#### 3.6 Check Pending PRs
**File**: `/app/api/github/check-prs/route.ts`
```typescript
export async function POST(request: Request) {
  const { deployments } = await request.json() // Array of deployment names

  // Get cached PRs
  const cachedPRs = PRCache.getCachedPRs()

  // Check GitHub API for each cached PR to see if it's still open
  const github = new GitHubClient(session.accessToken)
  const pendingPRs = []

  for (const cached of cachedPRs) {
    const isMerged = await github.isPullRequestMerged(cached.owner, cached.repo, cached.prNumber)
    if (!isMerged) {
      pendingPRs.push(cached)
    } else {
      PRCache.removePR(cached.deploymentName, cached.namespace)
    }
  }

  return Response.json({ pendingPRs })
}
```

**Tests**:
- `app/api/github/repos/route.test.ts`
- `app/api/github/create-pr/route.test.ts`
- E2E: Full PR creation flow with Playwright

---

### Phase 4: UI Components (8-10 hours)

#### 4.1 GitHub Login Button
**File**: `/app/components/github/login-button.tsx`
```typescript
'use client'

import { useSession, signIn, signOut } from 'next-auth/react'
import Button from '@mui/material/Button'
import GitHubIcon from '@mui/icons-material/GitHub'

export function GitHubLoginButton() {
  const { data: session, status } = useSession()

  if (status === 'loading') {
    return <Button disabled>Loading...</Button>
  }

  if (session) {
    return (
      <Button
        variant="outlined"
        startIcon={<GitHubIcon />}
        onClick={() => signOut()}
      >
        Sign out ({session.user?.name})
      </Button>
    )
  }

  return (
    <Button
      variant="contained"
      startIcon={<GitHubIcon />}
      onClick={() => signIn('github')}
    >
      Connect GitHub
    </Button>
  )
}
```

#### 4.2 Repository Selector
**File**: `/app/components/github/repo-selector.tsx`
```typescript
'use client'

import { useState, useEffect } from 'react'
import { useSession } from 'next-auth/react'
import Select from '@mui/material/Select'
import MenuItem from '@mui/material/MenuItem'
import FormControl from '@mui/material/FormControl'
import InputLabel from '@mui/material/InputLabel'
import { useStore } from '@/lib/store'

export function RepositorySelector() {
  const { data: session } = useSession()
  const { selectedRepo, setSelectedRepo } = useStore()
  const [repos, setRepos] = useState<Array<{ owner: string; repo: string; fullName: string }>>([])

  useEffect(() => {
    if (session?.accessToken) {
      fetch('/api/github/repos')
        .then(res => res.json())
        .then(data => setRepos(data))
    }
  }, [session])

  return (
    <FormControl fullWidth size="small">
      <InputLabel>GitHub Repository</InputLabel>
      <Select
        value={selectedRepo?.owner && selectedRepo?.repo ? `${selectedRepo.owner}/${selectedRepo.repo}` : ''}
        onChange={(e) => {
          const [owner, repo] = e.target.value.split('/')
          setSelectedRepo({ owner, repo, branch: 'main' })
        }}
        label="GitHub Repository"
      >
        {repos.map((repo) => (
          <MenuItem key={repo.fullName} value={repo.fullName}>
            {repo.fullName}
          </MenuItem>
        ))}
      </Select>
    </FormControl>
  )
}
```

#### 4.3 YAML Editor Modal
**File**: `/app/components/github/yaml-editor-modal.tsx`
```typescript
'use client'

import { useState, useEffect } from 'react'
import { useSession } from 'next-auth/react'
import Dialog from '@mui/material/Dialog'
import DialogTitle from '@mui/material/DialogTitle'
import DialogContent from '@mui/material/DialogContent'
import DialogActions from '@mui/material/DialogActions'
import Button from '@mui/material/Button'
import Box from '@mui/material/Box'
import Typography from '@mui/material/Typography'
import Tabs from '@mui/material/Tabs'
import Tab from '@mui/material/Tab'
import CircularProgress from '@mui/material/CircularProgress'
import Alert from '@mui/material/Alert'
import Select from '@mui/material/Select'
import MenuItem from '@mui/material/MenuItem'
import { YamlEditor } from '@/app/components/editor/yaml-editor'
import { useStore } from '@/lib/store'

interface YamlEditorModalProps {
  open: boolean
  onClose: () => void
  deployment: {
    name: string
    namespace: string
  }
}

export function YamlEditorModal({ open, onClose, deployment }: YamlEditorModalProps) {
  const { data: session } = useSession()
  const { selectedRepo } = useStore()

  const [loading, setLoading] = useState(true)
  const [yamlFiles, setYamlFiles] = useState<YamlFile[]>([])
  const [selectedFile, setSelectedFile] = useState<YamlFile | null>(null)
  const [yamlContent, setYamlContent] = useState('')
  const [originalContent, setOriginalContent] = useState('')
  const [isKustomize, setIsKustomize] = useState(false)
  const [kustomizeTab, setKustomizeTab] = useState<'base' | 'overlay'>(0)
  const [overlays, setOverlays] = useState<string[]>([])
  const [selectedOverlay, setSelectedOverlay] = useState<string>('')
  const [prCreated, setPrCreated] = useState<{ number: number; url: string } | null>(null)

  useEffect(() => {
    if (open && selectedRepo) {
      loadFiles()
    }
  }, [open, selectedRepo])

  const loadFiles = async () => {
    setLoading(true)

    // 1. List all YAML files in repo
    const filesRes = await fetch(`/api/github/files?owner=${selectedRepo.owner}&repo=${selectedRepo.repo}`)
    const files = await filesRes.json()
    setYamlFiles(files)

    // 2. Auto-match file for deployment
    const matchRes = await fetch('/api/github/match-file', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ deployment, yamlFiles: files }),
    })
    const { matchedFile } = await matchRes.json()

    if (matchedFile) {
      setSelectedFile(matchedFile)
      await loadFileContent(matchedFile)
    }

    setLoading(false)
  }

  const loadFileContent = async (file: YamlFile) => {
    // Get file content
    const res = await fetch(
      `/api/github/file?owner=${selectedRepo.owner}&repo=${selectedRepo.repo}&path=${file.path}`
    )
    const { content, sha } = await res.json()

    setYamlContent(content)
    setOriginalContent(content)
    setSelectedFile({ ...file, sha })

    // Check if this is a kustomization directory
    const dirPath = file.path.substring(0, file.path.lastIndexOf('/'))
    const kustomizeRes = await fetch(
      `/api/github/kustomize/detect?owner=${selectedRepo.owner}&repo=${selectedRepo.repo}&path=${dirPath}`
    )
    const { isKustomize, overlays } = await kustomizeRes.json()

    setIsKustomize(isKustomize)
    if (isKustomize && overlays.length > 0) {
      setOverlays(overlays)
      setSelectedOverlay(overlays[0])
    }
  }

  const handleCreatePR = async () => {
    const res = await fetch('/api/github/create-pr', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        owner: selectedRepo.owner,
        repo: selectedRepo.repo,
        filePath: selectedFile.path,
        content: yamlContent,
        deploymentName: deployment.name,
        namespace: deployment.namespace,
      }),
    })

    const pr = await res.json()
    setPrCreated(pr)
  }

  if (loading) {
    return (
      <Dialog open={open} onClose={onClose} maxWidth="md" fullWidth>
        <DialogContent>
          <Box sx={{ display: 'flex', justifyContent: 'center', p: 4 }}>
            <CircularProgress />
          </Box>
        </DialogContent>
      </Dialog>
    )
  }

  if (prCreated) {
    return (
      <Dialog open={open} onClose={onClose} maxWidth="sm" fullWidth>
        <DialogTitle>Pull Request Created</DialogTitle>
        <DialogContent>
          <Alert severity="success" sx={{ mb: 2 }}>
            PR #{prCreated.number} created successfully!
          </Alert>
          <Typography variant="body2" color="text.secondary">
            {prCreated.url}
          </Typography>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => window.open(prCreated.url, '_blank')} variant="contained">
            Open PR in GitHub
          </Button>
          <Button onClick={onClose}>
            Close
          </Button>
        </DialogActions>
      </Dialog>
    )
  }

  return (
    <Dialog open={open} onClose={onClose} maxWidth="lg" fullWidth>
      <DialogTitle>
        Edit YAML - {deployment.name}
      </DialogTitle>
      <DialogContent>
        {/* File Selector */}
        <Box sx={{ mb: 2 }}>
          <Select
            fullWidth
            value={selectedFile?.path || ''}
            onChange={(e) => {
              const file = yamlFiles.find(f => f.path === e.target.value)
              if (file) loadFileContent(file)
            }}
            size="small"
          >
            {yamlFiles.map(file => (
              <MenuItem key={file.path} value={file.path}>
                {file.path}
              </MenuItem>
            ))}
          </Select>
        </Box>

        {/* Kustomize Tabs */}
        {isKustomize && (
          <Box sx={{ mb: 2 }}>
            <Tabs value={kustomizeTab} onChange={(_, v) => setKustomizeTab(v)}>
              <Tab label="Base" value="base" />
              <Tab label="Overlays" value="overlay" />
            </Tabs>

            {kustomizeTab === 'overlay' && (
              <Select
                fullWidth
                value={selectedOverlay}
                onChange={(e) => setSelectedOverlay(e.target.value)}
                size="small"
                sx={{ mt: 1 }}
              >
                {overlays.map(overlay => (
                  <MenuItem key={overlay} value={overlay}>
                    {overlay}
                  </MenuItem>
                ))}
              </Select>
            )}
          </Box>
        )}

        {/* YAML Editor */}
        <YamlEditor
          value={yamlContent}
          onChange={setYamlContent}
          height="500px"
        />
      </DialogContent>
      <DialogActions>
        <Button onClick={onClose}>Cancel</Button>
        <Button
          onClick={handleCreatePR}
          variant="contained"
          disabled={yamlContent === originalContent}
        >
          Create Pull Request
        </Button>
      </DialogActions>
    </Dialog>
  )
}
```

#### 4.4 Pending PR Badge
**File**: `/app/components/github/pr-badge.tsx`
```typescript
'use client'

import { useEffect, useState } from 'react'
import Chip from '@mui/material/Chip'
import Tooltip from '@mui/material/Tooltip'
import { PRCache } from '@/lib/github/pr-cache'

export function PendingPRBadge({
  deploymentName,
  namespace
}: {
  deploymentName: string
  namespace: string
}) {
  const [pr, setPR] = useState<{ number: number; url: string } | null>(null)

  useEffect(() => {
    const cached = PRCache.getPRForDeployment(deploymentName, namespace)
    if (cached) {
      setPR({ number: cached.prNumber, url: cached.prUrl })
    }
  }, [deploymentName, namespace])

  if (!pr) return null

  return (
    <Tooltip title={`Open PR #${pr.number}`}>
      <Chip
        label={`PR #${pr.number}`}
        size="small"
        color="warning"
        clickable
        onClick={() => window.open(pr.url, '_blank')}
      />
    </Tooltip>
  )
}
```

#### 4.5 Update Deployment Details Page
**File**: `/app/deployments/[name]/page.tsx` (modify)
```typescript
// Add Edit YAML button
import { YamlEditorModal } from '@/app/components/github/yaml-editor-modal'

export default function DeploymentDetailsPage({ params }) {
  const [editorOpen, setEditorOpen] = useState(false)

  // ... existing code

  return (
    <Box>
      {/* Header with Edit button */}
      <Box sx={{ display: 'flex', gap: 2, mb: 3 }}>
        <Button
          variant="outlined"
          startIcon={<EditIcon />}
          onClick={() => setEditorOpen(true)}
        >
          Edit YAML
        </Button>
      </Box>

      {/* Existing content */}

      {/* YAML Editor Modal */}
      <YamlEditorModal
        open={editorOpen}
        onClose={() => setEditorOpen(false)}
        deployment={{ name: deployment.name, namespace: deployment.namespace }}
      />
    </Box>
  )
}
```

#### 4.6 Update Deployments List with Badges
**File**: `/app/deployments/page.tsx` (modify)
```typescript
import { PendingPRBadge } from '@/app/components/github/pr-badge'

// In the table/list rendering:
<Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
  <Typography>{deployment.name}</Typography>
  <PendingPRBadge
    deploymentName={deployment.name}
    namespace={deployment.namespace}
  />
</Box>
```

**Tests**:
- `app/components/github/yaml-editor-modal.test.tsx` - Component tests
- `app/components/github/pr-badge.test.tsx` - Badge rendering
- E2E: Full edit flow with Playwright

---

### Phase 5: ConfigMaps & Secrets Editor (4-6 hours)

#### 5.1 Add Edit Buttons to ConfigMap/Secret Details
**File**: `/app/configmaps/[name]/page.tsx` (modify)
**File**: `/app/secrets/[name]/page.tsx` (modify)

Same pattern as deployments - add [Edit YAML] button that opens modal.

#### 5.2 ConfigMap/Secret YAML Editor Modal
Reuse `YamlEditorModal` component with different resource type prop.

**Tests**:
- E2E: Edit ConfigMap flow
- E2E: Edit Secret flow

---

### Phase 6: Settings Integration (2-3 hours)

#### 6.1 Add GitHub Section to Settings
**File**: `/app/settings/page.tsx` (modify)
```typescript
<Paper sx={{ p: 3 }}>
  <Typography variant="h6" gutterBottom>
    GitHub Integration
  </Typography>

  <Box sx={{ mb: 2 }}>
    <GitHubLoginButton />
  </Box>

  {session && (
    <Box sx={{ mb: 2 }}>
      <RepositorySelector />
    </Box>
  )}
</Paper>
```

---

### Phase 7: Documentation (2-3 hours)

#### 7.1 Update README.md
Add section:
- How to create GitHub OAuth App
- Required scopes
- Environment variables setup

#### 7.2 Create GitHub OAuth Setup Guide
**File**: `/docs/github-setup.md`

Step-by-step guide with screenshots.

---

## Testing Strategy

### Unit Tests (Vitest)
- `lib/github/client.test.ts` - GitHub API client methods
- `lib/github/file-matcher.test.ts` - Pattern matching & LLM matching
- `lib/github/pr-cache.test.ts` - localStorage operations
- `app/components/github/pr-badge.test.tsx` - Component rendering

### Integration Tests (Vitest)
- `app/api/github/repos/route.test.ts` - API route handlers
- `app/api/github/create-pr/route.test.ts` - PR creation flow

### E2E Tests (Playwright)
- GitHub OAuth login flow
- Repository selection
- File matching
- YAML editing
- PR creation
- Badge display
- Cache persistence

## Time Estimate

| Phase | Hours |
|-------|-------|
| Phase 1: GitHub OAuth Setup | 4-6 |
| Phase 2: GitHub API Client | 6-8 |
| Phase 3: API Routes | 4-6 |
| Phase 4: UI Components | 8-10 |
| Phase 5: ConfigMaps & Secrets | 4-6 |
| Phase 6: Settings Integration | 2-3 |
| Phase 7: Documentation | 2-3 |
| **Total** | **30-42 hours** |

## Dependencies

```bash
npm install next-auth@beta @auth/core @octokit/rest ai @ai-sdk/openai
```

## Environment Variables

```env
GITHUB_CLIENT_ID=
GITHUB_CLIENT_SECRET=
NEXTAUTH_SECRET=
NEXTAUTH_URL=http://localhost:3000
OPENAI_API_KEY= # Optional, for LLM file matching
```

## Future Enhancements

1. **Multi-file editing**: Edit multiple files in one PR
2. **Diff preview**: Show git diff before creating PR
3. **Branch selection**: Choose base branch (not just main)
4. **Merge from UI**: Allow merging PR directly from KubeVista
5. **Webhook integration**: Auto-refresh when PR is merged
6. **GitLab support**: Add GitLab as alternative to GitHub
7. **Local file editing**: Edit local files (not just GitHub)
