# 2.1 Advanced Topology View

## Overview
Enhanced topology visualization showing comprehensive resource relationships including Ingress routing, Service selection, ConfigMap/Secret consumption, PVC/PV storage chains, and HPA scaling relationships.

## User Flow

```
1. User navigates to /topology
2. Default view shows basic topology (current implementation)
3. User toggles "Advanced Mode" switch in top-right corner
4. Graph expands to show:
   - Ingress → Service routing chains
   - Service → Pod selectors
   - Pod → ConfigMap/Secret references
   - Pod → PVC → PV → StorageClass → Node
   - HPA → Deployment scaling relationships
5. User can:
   - Click nodes to see details in side panel
   - Hover edges to see relationship metadata (selectors, ports, paths)
   - Filter by resource type
   - Search for specific resources
   - Switch layouts (hierarchical, force-directed, radial)
```

## Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                     Topology Page                            │
│  ┌───────────────────────────────────────────────────────┐  │
│  │  Topology              [ Basic | Advanced ] toggle    │  │
│  ├───────────────────────────────────────────────────────┤  │
│  │                                                        │  │
│  │  ┌──────────────────────────────────────────────┐    │  │
│  │  │                                               │    │  │
│  │  │        ReactFlow Graph Canvas                │    │  │
│  │  │                                               │    │  │
│  │  │  Basic Mode:                                  │    │  │
│  │  │    Deployment → Pod → Node                   │    │  │
│  │  │                                               │    │  │
│  │  │  Advanced Mode:                              │    │  │
│  │  │    Ingress → Service → Deployment → Pod →   │    │  │
│  │  │    ConfigMap/Secret, PVC → PV → Node        │    │  │
│  │  │                                               │    │  │
│  │  └──────────────────────────────────────────────┘    │  │
│  │                                                        │  │
│  │  Filters: [All] [Ingress] [Service] [Deployment]     │  │
│  │  Layout:  [Hierarchical] [Force] [Radial]            │  │
│  └───────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

### Advanced Topology Graph Example

```
                    ┌─────────────────────┐
                    │  Ingress: app.com   │ (Globe icon, blue)
                    │  [2/2 backends]     │
                    └─────────────────────┘
                             │
                             │ routes: /api → nginx-service
                             ▼
                    ┌─────────────────────┐
                    │ Service: nginx      │ (Cloud icon, teal)
                    │ ClusterIP           │
                    │ [2/2 endpoints]     │
                    └─────────────────────┘
                             │
                             │ selects: app=nginx
                             ▼
          ┌──────────────────────────────────────┐
          │  Deployment: nginx-app               │ (Layers icon, indigo)
          │  [2/2 replicas]                      │
          └──────────────────────────────────────┘
                    │                    │
                    │ scaled by          │
        ┌───────────┘                    └──────────────┐
        │                                                │
        ▼                                                ▼
┌───────────────┐                              ┌───────────────┐
│ HPA: nginx-hpa│ (Chart icon, yellow)         │ Pod: nginx-1  │ (Box icon, purple)
│ CPU: 45%      │                              │ Running       │
│ Target: 50%   │                              │ CPU: 45%      │
└───────────────┘                              └───────────────┘
                                                        │
                    ┌──────────────┬────────────────────┤
                    │              │                    │
                    ▼              ▼                    ▼
          ┌─────────────┐  ┌─────────────┐    ┌─────────────┐
          │ ConfigMap:  │  │ Secret:     │    │ PVC: data   │ (Database icon, orange)
          │ nginx-config│  │ tls-cert    │    │ [Bound]     │
          └─────────────┘  └─────────────┘    └─────────────┘
          (File icon,      (Lock icon,                │
           green)          red)                       │
                                                      ▼
                                             ┌─────────────┐
                                             │ PV: pv-123  │
                                             │ 10Gi        │
                                             └─────────────┘
                                                      │
                                                      ▼
                                             ┌─────────────┐
                                             │ StorageClass│
                                             │ gp3 (AWS)   │
                                             └─────────────┘
                                                      │
                                                      ▼
                                             ┌─────────────┐
                                             │ Node:       │ (Server icon, gray)
                                             │ worker-1    │
                                             │ [Ready]     │
                                             └─────────────┘
```

## Implementation Plan

### Phase 1: Data Model & API (6-8 hours)

#### 1.1 Enhanced Topology Data Types
**File**: `/lib/types/topology.ts`
```typescript
export type ResourceType =
  | 'ingress'
  | 'service'
  | 'deployment'
  | 'pod'
  | 'configmap'
  | 'secret'
  | 'pvc'
  | 'pv'
  | 'storageclass'
  | 'node'
  | 'hpa'

export type EdgeType =
  | 'routes'        // Ingress → Service
  | 'selects'       // Service → Pod (selector)
  | 'scales'        // HPA → Deployment
  | 'mounts'        // Pod → PVC
  | 'binds'         // PVC → PV
  | 'uses'          // Pod → ConfigMap/Secret
  | 'schedules'     // Pod → Node
  | 'provisions'    // StorageClass → PV

export interface TopologyNode {
  id: string
  type: ResourceType
  label: string
  namespace?: string
  status: 'healthy' | 'warning' | 'error' | 'unknown'
  metadata: {
    // Common
    age?: string

    // Deployment/ReplicaSet
    replicas?: { ready: number; desired: number }

    // Service
    endpoints?: { ready: number; total: number }
    clusterIP?: string
    type?: string

    // Pod
    cpu?: string
    memory?: string
    restarts?: number

    // PV/PVC
    capacity?: string
    storageClass?: string

    // HPA
    currentCPU?: number
    targetCPU?: number

    // Node
    cpuCapacity?: string
    memoryCapacity?: string
  }
  position?: { x: number; y: number } // For layout persistence
}

export interface TopologyEdge {
  id: string
  source: string
  target: string
  type: EdgeType
  label?: string
  metadata?: {
    // Service → Pod selector
    selector?: Record<string, string>

    // Ingress → Service routing
    paths?: string[]
    host?: string

    // Pod → ConfigMap/Secret
    mountPath?: string
    volumeName?: string

    // Service ports
    ports?: Array<{ port: number; targetPort: number; protocol: string }>
  }
  animated?: boolean
}

export interface TopologyGraph {
  nodes: TopologyNode[]
  edges: TopologyEdge[]
  mode: 'basic' | 'advanced'
}
```

#### 1.2 Enhanced Topology API
**File**: `/app/api/topology/advanced/route.ts`
```typescript
import { NextRequest, NextResponse } from 'next/server'
import { getKubeConfig } from '@/lib/kubernetes/client'
import type { TopologyGraph, TopologyNode, TopologyEdge } from '@/lib/types/topology'

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url)
  const namespace = searchParams.get('namespace') || 'default'
  const mode = searchParams.get('mode') || 'basic'

  try {
    const kc = getKubeConfig()
    const k8sApi = kc.makeApiClient(CoreV1Api)
    const appsApi = kc.makeApiClient(AppsV1Api)
    const networkingApi = kc.makeApiClient(NetworkingV1Api)
    const autoscalingApi = kc.makeApiClient(AutoscalingV2Api)
    const storageApi = kc.makeApiClient(StorageV1Api)

    // Fetch all resources in parallel
    const [
      deployments,
      pods,
      services,
      ingresses,
      configMaps,
      secrets,
      pvcs,
      pvs,
      hpas,
      nodes,
      storageClasses,
    ] = await Promise.all([
      appsApi.listNamespacedDeployment(namespace),
      k8sApi.listNamespacedPod(namespace),
      k8sApi.listNamespacedService(namespace),
      networkingApi.listNamespacedIngress(namespace),
      k8sApi.listNamespacedConfigMap(namespace),
      k8sApi.listNamespacedSecret(namespace),
      k8sApi.listNamespacedPersistentVolumeClaim(namespace),
      k8sApi.listPersistentVolume(),
      autoscalingApi.listNamespacedHorizontalPodAutoscaler(namespace),
      k8sApi.listNode(),
      storageApi.listStorageClass(),
    ])

    const graph: TopologyGraph = {
      nodes: [],
      edges: [],
      mode: mode as 'basic' | 'advanced',
    }

    // Build nodes and edges based on mode
    if (mode === 'basic') {
      buildBasicTopology(graph, deployments.body.items, pods.body.items, nodes.body.items)
    } else {
      buildAdvancedTopology(
        graph,
        deployments.body.items,
        pods.body.items,
        services.body.items,
        ingresses.body.items,
        configMaps.body.items,
        secrets.body.items,
        pvcs.body.items,
        pvs.body.items,
        hpas.body.items,
        nodes.body.items,
        storageClasses.body.items
      )
    }

    return NextResponse.json(graph)
  } catch (error) {
    console.error('Failed to fetch advanced topology:', error)
    return NextResponse.json(
      { error: 'Failed to fetch topology data' },
      { status: 500 }
    )
  }
}

function buildBasicTopology(
  graph: TopologyGraph,
  deployments: any[],
  pods: any[],
  nodes: any[]
) {
  // Current implementation - reuse existing logic
  // Deployment → Pod → Node
}

function buildAdvancedTopology(
  graph: TopologyGraph,
  deployments: any[],
  pods: any[],
  services: any[],
  ingresses: any[],
  configMaps: any[],
  secrets: any[],
  pvcs: any[],
  pvs: any[],
  hpas: any[],
  nodes: any[],
  storageClasses: any[]
) {
  // 1. Add Ingress nodes
  for (const ingress of ingresses) {
    const backendCount = ingress.spec?.rules?.reduce((count, rule) => {
      return count + (rule.http?.paths?.length || 0)
    }, 0) || 0

    graph.nodes.push({
      id: `ingress-${ingress.metadata.name}`,
      type: 'ingress',
      label: ingress.metadata.name!,
      namespace: ingress.metadata.namespace,
      status: 'healthy', // TODO: Check ingress status
      metadata: {
        age: formatAge(ingress.metadata.creationTimestamp),
      },
    })

    // Create edges: Ingress → Service
    for (const rule of ingress.spec?.rules || []) {
      for (const path of rule.http?.paths || []) {
        const serviceName = path.backend?.service?.name
        if (serviceName) {
          graph.edges.push({
            id: `ingress-${ingress.metadata.name}-service-${serviceName}`,
            source: `ingress-${ingress.metadata.name}`,
            target: `service-${serviceName}`,
            type: 'routes',
            label: `${rule.host || '*'}${path.path || '/'}`,
            metadata: {
              paths: [path.path || '/'],
              host: rule.host,
            },
          })
        }
      }
    }
  }

  // 2. Add Service nodes
  for (const service of services) {
    const endpoints = 0 // TODO: Fetch endpoints

    graph.nodes.push({
      id: `service-${service.metadata.name}`,
      type: 'service',
      label: service.metadata.name!,
      namespace: service.metadata.namespace,
      status: 'healthy',
      metadata: {
        endpoints: { ready: endpoints, total: endpoints },
        clusterIP: service.spec?.clusterIP,
        type: service.spec?.type,
      },
    })

    // Create edges: Service → Pod (via selector)
    const selector = service.spec?.selector
    if (selector) {
      const matchingPods = pods.filter(pod =>
        Object.entries(selector).every(([key, value]) =>
          pod.metadata?.labels?.[key] === value
        )
      )

      for (const pod of matchingPods) {
        graph.edges.push({
          id: `service-${service.metadata.name}-pod-${pod.metadata.name}`,
          source: `service-${service.metadata.name}`,
          target: `pod-${pod.metadata.name}`,
          type: 'selects',
          label: Object.entries(selector).map(([k, v]) => `${k}=${v}`).join(', '),
          metadata: {
            selector,
            ports: service.spec?.ports,
          },
        })
      }
    }
  }

  // 3. Add Deployment nodes
  for (const deployment of deployments) {
    graph.nodes.push({
      id: `deployment-${deployment.metadata.name}`,
      type: 'deployment',
      label: deployment.metadata.name!,
      namespace: deployment.metadata.namespace,
      status: deployment.status?.availableReplicas === deployment.spec?.replicas ? 'healthy' : 'warning',
      metadata: {
        replicas: {
          ready: deployment.status?.availableReplicas || 0,
          desired: deployment.spec?.replicas || 0,
        },
      },
    })

    // Create edges: Deployment → Pod (owned pods)
    const deploymentPods = pods.filter(pod =>
      pod.metadata?.ownerReferences?.some(
        ref => ref.kind === 'ReplicaSet' && ref.name?.startsWith(deployment.metadata.name!)
      )
    )

    for (const pod of deploymentPods) {
      graph.edges.push({
        id: `deployment-${deployment.metadata.name}-pod-${pod.metadata.name}`,
        source: `deployment-${deployment.metadata.name}`,
        target: `pod-${pod.metadata.name}`,
        type: 'manages',
      })
    }
  }

  // 4. Add HPA nodes
  for (const hpa of hpas) {
    const targetRef = hpa.spec?.scaleTargetRef
    if (targetRef?.kind === 'Deployment') {
      graph.nodes.push({
        id: `hpa-${hpa.metadata.name}`,
        type: 'hpa',
        label: hpa.metadata.name!,
        namespace: hpa.metadata.namespace,
        status: 'healthy',
        metadata: {
          currentCPU: hpa.status?.currentMetrics?.[0]?.resource?.current?.averageUtilization,
          targetCPU: hpa.spec?.metrics?.[0]?.resource?.target?.averageUtilization,
        },
      })

      graph.edges.push({
        id: `hpa-${hpa.metadata.name}-deployment-${targetRef.name}`,
        source: `hpa-${hpa.metadata.name}`,
        target: `deployment-${targetRef.name}`,
        type: 'scales',
        label: `Target: ${hpa.spec?.metrics?.[0]?.resource?.target?.averageUtilization}%`,
        animated: true,
      })
    }
  }

  // 5. Add Pod nodes
  for (const pod of pods) {
    graph.nodes.push({
      id: `pod-${pod.metadata.name}`,
      type: 'pod',
      label: pod.metadata.name!,
      namespace: pod.metadata.namespace,
      status: pod.status?.phase === 'Running' ? 'healthy' : 'warning',
      metadata: {
        cpu: '45m', // TODO: Fetch from metrics
        memory: '128Mi',
        restarts: pod.status?.containerStatuses?.[0]?.restartCount || 0,
      },
    })

    // Create edges: Pod → ConfigMap
    for (const volume of pod.spec?.volumes || []) {
      if (volume.configMap) {
        const cmName = volume.configMap.name

        // Add ConfigMap node if not exists
        if (!graph.nodes.find(n => n.id === `configmap-${cmName}`)) {
          graph.nodes.push({
            id: `configmap-${cmName}`,
            type: 'configmap',
            label: cmName!,
            namespace: pod.metadata.namespace,
            status: 'healthy',
            metadata: {},
          })
        }

        graph.edges.push({
          id: `pod-${pod.metadata.name}-cm-${cmName}`,
          source: `pod-${pod.metadata.name}`,
          target: `configmap-${cmName}`,
          type: 'uses',
          label: volume.name,
          metadata: { volumeName: volume.name },
        })
      }

      if (volume.secret) {
        const secretName = volume.secret.secretName

        // Add Secret node if not exists
        if (!graph.nodes.find(n => n.id === `secret-${secretName}`)) {
          graph.nodes.push({
            id: `secret-${secretName}`,
            type: 'secret',
            label: secretName!,
            namespace: pod.metadata.namespace,
            status: 'healthy',
            metadata: {},
          })
        }

        graph.edges.push({
          id: `pod-${pod.metadata.name}-secret-${secretName}`,
          source: `pod-${pod.metadata.name}`,
          target: `secret-${secretName}`,
          type: 'uses',
          label: volume.name,
          metadata: { volumeName: volume.name },
        })
      }

      if (volume.persistentVolumeClaim) {
        const pvcName = volume.persistentVolumeClaim.claimName

        graph.edges.push({
          id: `pod-${pod.metadata.name}-pvc-${pvcName}`,
          source: `pod-${pod.metadata.name}`,
          target: `pvc-${pvcName}`,
          type: 'mounts',
          label: volume.name,
        })
      }
    }

    // Create edges: Pod → Node
    if (pod.spec?.nodeName) {
      graph.edges.push({
        id: `pod-${pod.metadata.name}-node-${pod.spec.nodeName}`,
        source: `pod-${pod.metadata.name}`,
        target: `node-${pod.spec.nodeName}`,
        type: 'schedules',
      })
    }
  }

  // 6. Add PVC nodes
  for (const pvc of pvcs) {
    graph.nodes.push({
      id: `pvc-${pvc.metadata.name}`,
      type: 'pvc',
      label: pvc.metadata.name!,
      namespace: pvc.metadata.namespace,
      status: pvc.status?.phase === 'Bound' ? 'healthy' : 'warning',
      metadata: {
        capacity: pvc.spec?.resources?.requests?.storage,
        storageClass: pvc.spec?.storageClassName,
      },
    })

    // Create edges: PVC → PV
    if (pvc.spec?.volumeName) {
      graph.edges.push({
        id: `pvc-${pvc.metadata.name}-pv-${pvc.spec.volumeName}`,
        source: `pvc-${pvc.metadata.name}`,
        target: `pv-${pvc.spec.volumeName}`,
        type: 'binds',
      })
    }
  }

  // 7. Add PV nodes
  for (const pv of pvs) {
    graph.nodes.push({
      id: `pv-${pv.metadata.name}`,
      type: 'pv',
      label: pv.metadata.name!,
      status: pv.status?.phase === 'Bound' ? 'healthy' : 'warning',
      metadata: {
        capacity: pv.spec?.capacity?.storage,
        storageClass: pv.spec?.storageClassName,
      },
    })

    // Create edges: PV → StorageClass
    if (pv.spec?.storageClassName) {
      // Add StorageClass node if not exists
      if (!graph.nodes.find(n => n.id === `sc-${pv.spec.storageClassName}`)) {
        const sc = storageClasses.find(s => s.metadata?.name === pv.spec?.storageClassName)
        if (sc) {
          graph.nodes.push({
            id: `sc-${sc.metadata.name}`,
            type: 'storageclass',
            label: sc.metadata.name!,
            status: 'healthy',
            metadata: {},
          })
        }
      }

      graph.edges.push({
        id: `pv-${pv.metadata.name}-sc-${pv.spec.storageClassName}`,
        source: `pv-${pv.metadata.name}`,
        target: `sc-${pv.spec.storageClassName}`,
        type: 'provisions',
      })
    }
  }

  // 8. Add Node nodes
  for (const node of nodes) {
    graph.nodes.push({
      id: `node-${node.metadata.name}`,
      type: 'node',
      label: node.metadata.name!,
      status: node.status?.conditions?.some(c => c.type === 'Ready' && c.status === 'True') ? 'healthy' : 'error',
      metadata: {
        cpuCapacity: node.status?.capacity?.cpu,
        memoryCapacity: node.status?.capacity?.memory,
      },
    })
  }
}
```

**Tests**:
- `app/api/topology/advanced/route.test.ts` - Test topology building logic
- Mock K8s API responses

---

### Phase 2: UI Components (10-12 hours)

#### 2.1 Mode Toggle Switch
**File**: `/app/components/topology/mode-toggle.tsx`
```typescript
'use client'

import { useState } from 'react'
import ToggleButtonGroup from '@mui/material/ToggleButtonGroup'
import ToggleButton from '@mui/material/ToggleButton'
import Box from '@mui/material/Box'

export function TopologyModeToggle({
  value,
  onChange
}: {
  value: 'basic' | 'advanced'
  onChange: (mode: 'basic' | 'advanced') => void
}) {
  return (
    <Box>
      <ToggleButtonGroup
        value={value}
        exclusive
        onChange={(_, newValue) => {
          if (newValue !== null) {
            onChange(newValue)
          }
        }}
        size="small"
      >
        <ToggleButton value="basic">
          Basic
        </ToggleButton>
        <ToggleButton value="advanced">
          Advanced
        </ToggleButton>
      </ToggleButtonGroup>
    </Box>
  )
}
```

#### 2.2 Enhanced Node Component
**File**: `/app/components/topology/topology-node.tsx`
```typescript
'use client'

import { memo } from 'react'
import { Handle, Position } from '@xyflow/react'
import Box from '@mui/material/Box'
import Typography from '@mui/material/Typography'
import Chip from '@mui/material/Chip'

// Icons for different resource types
import LanguageIcon from '@mui/icons-material/Language' // Ingress
import CloudIcon from '@mui/icons-material/Cloud' // Service
import LayersIcon from '@mui/icons-material/Layers' // Deployment
import ViewInArIcon from '@mui/icons-material/ViewInAr' // Pod
import DescriptionIcon from '@mui/icons-material/Description' // ConfigMap
import LockIcon from '@mui/icons-material/Lock' // Secret
import StorageIcon from '@mui/icons-material/Storage' // PVC/PV
import DnsIcon from '@mui/icons-material/Dns' // Node
import TrendingUpIcon from '@mui/icons-material/TrendingUp' // HPA
import ClassIcon from '@mui/icons-material/Class' // StorageClass

const iconMap = {
  ingress: LanguageIcon,
  service: CloudIcon,
  deployment: LayersIcon,
  pod: ViewInArIcon,
  configmap: DescriptionIcon,
  secret: LockIcon,
  pvc: StorageIcon,
  pv: StorageIcon,
  storageclass: ClassIcon,
  node: DnsIcon,
  hpa: TrendingUpIcon,
}

const colorMap = {
  ingress: '#2196F3',      // Blue
  service: '#00BCD4',      // Teal
  deployment: '#3F51B5',   // Indigo
  pod: '#9C27B0',          // Purple
  configmap: '#4CAF50',    // Green
  secret: '#F44336',       // Red
  pvc: '#FF9800',          // Orange
  pv: '#FF9800',           // Orange
  storageclass: '#795548', // Brown
  node: '#607D8B',         // Gray
  hpa: '#FFEB3B',          // Yellow
}

const statusColorMap = {
  healthy: '#4CAF50',
  warning: '#FF9800',
  error: '#F44336',
  unknown: '#9E9E9E',
}

export const TopologyNode = memo(({ data }: { data: any }) => {
  const Icon = iconMap[data.type] || ViewInArIcon
  const bgColor = colorMap[data.type] || '#9E9E9E'
  const statusColor = statusColorMap[data.status] || '#9E9E9E'

  return (
    <>
      <Handle type="target" position={Position.Top} />

      <Box
        sx={{
          padding: 2,
          borderRadius: 2,
          backgroundColor: 'background.paper',
          border: `2px solid ${bgColor}`,
          minWidth: 180,
          boxShadow: 2,
          position: 'relative',
          '&:hover': {
            boxShadow: 4,
          },
        }}
      >
        {/* Status indicator */}
        <Box
          sx={{
            position: 'absolute',
            top: 8,
            right: 8,
            width: 12,
            height: 12,
            borderRadius: '50%',
            backgroundColor: statusColor,
            animation: data.status === 'healthy' ? 'pulse 2s infinite' : 'none',
          }}
        />

        {/* Icon and label */}
        <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 1 }}>
          <Icon sx={{ color: bgColor }} />
          <Typography variant="subtitle2" fontWeight="bold" noWrap>
            {data.label}
          </Typography>
        </Box>

        {/* Metadata */}
        {data.metadata?.replicas && (
          <Typography variant="caption" color="text.secondary">
            {data.metadata.replicas.ready}/{data.metadata.replicas.desired} replicas
          </Typography>
        )}

        {data.metadata?.endpoints && (
          <Typography variant="caption" color="text.secondary">
            {data.metadata.endpoints.ready}/{data.metadata.endpoints.total} endpoints
          </Typography>
        )}

        {data.metadata?.cpu && (
          <Typography variant="caption" color="text.secondary">
            CPU: {data.metadata.cpu} | Mem: {data.metadata.memory}
          </Typography>
        )}

        {data.metadata?.currentCPU !== undefined && (
          <Typography variant="caption" color="text.secondary">
            {data.metadata.currentCPU}% / {data.metadata.targetCPU}% target
          </Typography>
        )}

        {data.metadata?.capacity && (
          <Typography variant="caption" color="text.secondary">
            {data.metadata.capacity}
          </Typography>
        )}

        {data.namespace && (
          <Chip
            label={data.namespace}
            size="small"
            sx={{ mt: 1, height: 20, fontSize: '0.7rem' }}
          />
        )}
      </Box>

      <Handle type="source" position={Position.Bottom} />
    </>
  )
})

TopologyNode.displayName = 'TopologyNode'
```

#### 2.3 Enhanced Edge Component
**File**: `/app/components/topology/topology-edge.tsx`
```typescript
'use client'

import { memo } from 'react'
import {
  BaseEdge,
  EdgeLabelRenderer,
  getBezierPath,
  EdgeProps,
} from '@xyflow/react'
import Chip from '@mui/material/Chip'

const edgeStyleMap = {
  routes: { stroke: '#2196F3', strokeWidth: 2, strokeDasharray: '0' },
  selects: { stroke: '#00BCD4', strokeWidth: 2, strokeDasharray: '5,5' },
  scales: { stroke: '#FFEB3B', strokeWidth: 2, strokeDasharray: '2,2' },
  mounts: { stroke: '#FF9800', strokeWidth: 3, strokeDasharray: '0' },
  binds: { stroke: '#FF9800', strokeWidth: 2, strokeDasharray: '0' },
  uses: { stroke: '#4CAF50', strokeWidth: 1, strokeDasharray: '0' },
  schedules: { stroke: '#607D8B', strokeWidth: 1, strokeDasharray: '0' },
  provisions: { stroke: '#795548', strokeWidth: 2, strokeDasharray: '0' },
}

export const TopologyEdge = memo(({
  id,
  sourceX,
  sourceY,
  targetX,
  targetY,
  sourcePosition,
  targetPosition,
  data,
  markerEnd,
}: EdgeProps) => {
  const [edgePath, labelX, labelY] = getBezierPath({
    sourceX,
    sourceY,
    sourcePosition,
    targetX,
    targetY,
    targetPosition,
  })

  const style = edgeStyleMap[data?.type] || { stroke: '#999', strokeWidth: 1 }

  return (
    <>
      <BaseEdge
        id={id}
        path={edgePath}
        markerEnd={markerEnd}
        style={style}
      />

      {data?.label && (
        <EdgeLabelRenderer>
          <div
            style={{
              position: 'absolute',
              transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,
              pointerEvents: 'all',
            }}
          >
            <Chip
              label={data.label}
              size="small"
              sx={{
                fontSize: '0.65rem',
                height: 20,
                backgroundColor: 'background.paper',
                border: '1px solid',
                borderColor: 'divider',
              }}
            />
          </div>
        </EdgeLabelRenderer>
      )}
    </>
  )
})

TopologyEdge.displayName = 'TopologyEdge'
```

#### 2.4 Update Topology Page
**File**: `/app/topology/page.tsx` (major refactor)
```typescript
'use client'

import { useState, useCallback, useEffect } from 'react'
import { useQuery } from '@tanstack/react-query'
import Box from '@mui/material/Box'
import Paper from '@mui/material/Paper'
import Typography from '@mui/material/Typography'
import CircularProgress from '@mui/material/CircularProgress'
import {
  ReactFlow,
  Background,
  Controls,
  MiniMap,
  useNodesState,
  useEdgesState,
  Node,
  Edge,
} from '@xyflow/react'
import '@xyflow/react/dist/style.css'
import { TopologyModeToggle } from '@/app/components/topology/mode-toggle'
import { TopologyNode } from '@/app/components/topology/topology-node'
import { TopologyEdge } from '@/app/components/topology/topology-edge'
import { useStore } from '@/lib/store'
import dagre from 'dagre'

const nodeTypes = {
  custom: TopologyNode,
}

const edgeTypes = {
  custom: TopologyEdge,
}

// Layout algorithm using Dagre
function getLayoutedElements(nodes: Node[], edges: Edge[], direction = 'TB') {
  const dagreGraph = new dagre.graphlib.Graph()
  dagreGraph.setDefaultEdgeLabel(() => ({}))
  dagreGraph.setGraph({ rankdir: direction })

  nodes.forEach((node) => {
    dagreGraph.setNode(node.id, { width: 200, height: 100 })
  })

  edges.forEach((edge) => {
    dagreGraph.setEdge(edge.source, edge.target)
  })

  dagre.layout(dagreGraph)

  const layoutedNodes = nodes.map((node) => {
    const nodeWithPosition = dagreGraph.node(node.id)
    return {
      ...node,
      position: {
        x: nodeWithPosition.x - 100,
        y: nodeWithPosition.y - 50,
      },
    }
  })

  return { nodes: layoutedNodes, edges }
}

export default function TopologyPage() {
  const { selectedNamespace } = useStore()
  const [mode, setMode] = useState<'basic' | 'advanced'>('basic')
  const [nodes, setNodes, onNodesChange] = useNodesState([])
  const [edges, setEdges, onEdgesChange] = useEdgesState([])

  const { data: topologyData, isLoading } = useQuery({
    queryKey: ['topology', selectedNamespace, mode],
    queryFn: async () => {
      const response = await fetch(
        `/api/topology/advanced?namespace=${selectedNamespace}&mode=${mode}`
      )
      if (!response.ok) throw new Error('Failed to fetch topology')
      return response.json()
    },
    refetchInterval: mode === 'basic' ? 10000 : false, // Refresh basic mode every 10s
  })

  useEffect(() => {
    if (topologyData) {
      const reactFlowNodes: Node[] = topologyData.nodes.map((node) => ({
        id: node.id,
        type: 'custom',
        data: node,
        position: node.position || { x: 0, y: 0 },
      }))

      const reactFlowEdges: Edge[] = topologyData.edges.map((edge) => ({
        id: edge.id,
        source: edge.source,
        target: edge.target,
        type: 'custom',
        data: edge,
        animated: edge.animated || false,
        markerEnd: { type: 'arrowclosed' },
      }))

      // Auto-layout
      const { nodes: layoutedNodes, edges: layoutedEdges } = getLayoutedElements(
        reactFlowNodes,
        reactFlowEdges
      )

      setNodes(layoutedNodes)
      setEdges(layoutedEdges)
    }
  }, [topologyData, setNodes, setEdges])

  const onNodeClick = useCallback((event: React.MouseEvent, node: Node) => {
    console.log('Node clicked:', node.data)
    // TODO: Open side panel with node details
  }, [])

  if (isLoading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '80vh' }}>
        <CircularProgress />
      </Box>
    )
  }

  return (
    <Box>
      <Box sx={{ mb: 3, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
        <Typography variant="h4">Topology</Typography>
        <TopologyModeToggle value={mode} onChange={setMode} />
      </Box>

      <Paper sx={{ height: '75vh', overflow: 'hidden' }}>
        <ReactFlow
          nodes={nodes}
          edges={edges}
          onNodesChange={onNodesChange}
          onEdgesChange={onEdgesChange}
          onNodeClick={onNodeClick}
          nodeTypes={nodeTypes}
          edgeTypes={edgeTypes}
          fitView
        >
          <Background />
          <Controls />
          <MiniMap />
        </ReactFlow>
      </Paper>
    </Box>
  )
}
```

**Tests**:
- `app/components/topology/topology-node.test.tsx` - Node rendering
- `app/components/topology/topology-edge.test.tsx` - Edge rendering
- E2E: Switch between basic/advanced modes with Playwright

---

### Phase 3: Layout & Interactions (4-6 hours)

#### 3.1 Install Dagre for Auto-layout
```bash
npm install dagre @types/dagre
```

#### 3.2 Add Layout Selector
Allow users to switch between:
- Hierarchical (top-down)
- Force-directed
- Radial

#### 3.3 Add Resource Type Filters
Filter graph by resource type checkboxes.

#### 3.4 Add Node Details Side Panel
Click node → open drawer with full resource details.

**Tests**:
- E2E: Test layout switching
- E2E: Test filters
- E2E: Test side panel

---

## Testing Strategy

### Unit Tests (Vitest)
- `app/api/topology/advanced/route.test.ts` - Topology building logic
- `app/components/topology/topology-node.test.tsx` - Node component
- `app/components/topology/topology-edge.test.tsx` - Edge component

### Integration Tests (Vitest)
- Full topology graph rendering with mock data

### E2E Tests (Playwright)
- Switch between basic and advanced modes
- Verify correct node/edge rendering
- Click nodes to see details
- Test filters and layouts

## Time Estimate

| Phase | Hours |
|-------|-------|
| Phase 1: Data Model & API | 6-8 |
| Phase 2: UI Components | 10-12 |
| Phase 3: Layout & Interactions | 4-6 |
| **Total** | **20-26 hours** |

## Dependencies

```bash
npm install dagre @types/dagre
```

## Future Enhancements

1. **Health propagation**: Show how unhealthy pods affect upstream resources
2. **Cost overlay**: Show cost per node
3. **Security view**: Highlight security issues (privileged pods, etc.)
4. **Network policies**: Show NetworkPolicy enforcement
5. **Live metrics**: Show real-time CPU/memory on nodes
6. **Cluster-wide view**: Show cross-namespace relationships
