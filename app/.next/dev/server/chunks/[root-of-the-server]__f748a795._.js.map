{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 208, "column": 0}, "map": {"version":3,"sources":["file:///Users/dmakowski/git_priv/kubevista/lib/k8s/client.ts"],"sourcesContent":["/**\n * Kubernetes Client Configuration\n *\n * This module provides a configured Kubernetes client for interacting with\n * a Kubernetes cluster. It supports multiple authentication methods:\n * - Kubeconfig file (~/.kube/config)\n * - In-cluster configuration (for running inside a pod)\n * - Manual configuration\n */\n\nimport * as k8s from '@kubernetes/client-node'\n\nlet kc: k8s.KubeConfig | null = null\nlet k8sAppsApi: k8s.AppsV1Api | null = null\nlet k8sCoreApi: k8s.CoreV1Api | null = null\nlet k8sAutoscalingApi: k8s.AutoscalingV2Api | null = null\nlet k8sEventsApi: k8s.EventsV1Api | null = null\nlet k8sNetworkingApi: k8s.NetworkingV1Api | null = null\nlet k8sBatchApi: k8s.BatchV1Api | null = null\n\n/**\n * Initialize Kubernetes client\n * Tries in-cluster config first, then falls back to kubeconfig file\n * IMPORTANT: For AWS EKS, we must reload config on every call to refresh tokens\n *\n * @param contextName - Optional context name to switch to. If not provided, uses current context.\n */\nexport function initK8sClient(contextName?: string): void {\n  // Reset client to force reload (needed for AWS EKS exec auth)\n  kc = new k8s.KubeConfig()\n\n  // Always use kubeconfig file for development (not in-cluster)\n  // In-cluster config is only for when running inside Kubernetes pod\n  try {\n    // Load from kubeconfig file (~/.kube/config)\n    kc.loadFromDefault()\n\n    // Switch to specified context if provided\n    if (contextName) {\n      kc.setCurrentContext(contextName)\n    }\n\n    const cluster = kc.getCurrentCluster()\n    const currentCtx = kc.getCurrentContext()\n\n    // Validate cluster configuration\n    if (!cluster?.server) {\n      throw new Error(`Cluster server URL is not configured for context: ${contextName || currentCtx}`)\n    }\n  } catch (error) {\n    console.error('[K8s] Failed to load Kubernetes configuration:', error)\n    throw new Error('Failed to initialize Kubernetes client. Make sure kubeconfig is properly configured.')\n  }\n\n  // Initialize API clients (recreate on every call for fresh tokens)\n  k8sAppsApi = kc.makeApiClient(k8s.AppsV1Api)\n  k8sCoreApi = kc.makeApiClient(k8s.CoreV1Api)\n  k8sAutoscalingApi = kc.makeApiClient(k8s.AutoscalingV2Api)\n  k8sEventsApi = kc.makeApiClient(k8s.EventsV1Api)\n  k8sNetworkingApi = kc.makeApiClient(k8s.NetworkingV1Api)\n  k8sBatchApi = kc.makeApiClient(k8s.BatchV1Api)\n}\n\n/**\n * Get Apps V1 API client (for Deployments, StatefulSets, DaemonSets)\n * @param contextName - Optional context name to switch to\n */\nexport function getAppsApi(contextName?: string): k8s.AppsV1Api {\n  // Always reinitialize for AWS EKS to refresh tokens\n  initK8sClient(contextName)\n  return k8sAppsApi!\n}\n\n/**\n * Get Core V1 API client (for Pods, Services, ConfigMaps, Secrets, Nodes, PVs, PVCs)\n * @param contextName - Optional context name to switch to\n */\nexport function getCoreApi(contextName?: string): k8s.CoreV1Api {\n  // Always reinitialize for AWS EKS to refresh tokens\n  initK8sClient(contextName)\n  return k8sCoreApi!\n}\n\n/**\n * Get Autoscaling V2 API client (for HPAs)\n * @param contextName - Optional context name to switch to\n */\nexport function getAutoscalingApi(contextName?: string): k8s.AutoscalingV2Api {\n  // Always reinitialize for AWS EKS to refresh tokens\n  initK8sClient(contextName)\n  return k8sAutoscalingApi!\n}\n\n/**\n * Get Events V1 API client\n * @param contextName - Optional context name to switch to\n */\nexport function getEventsApi(contextName?: string): k8s.EventsV1Api {\n  // Always reinitialize for AWS EKS to refresh tokens\n  initK8sClient(contextName)\n  return k8sEventsApi!\n}\n\n/**\n * Get Networking V1 API client (for Ingress)\n * @param contextName - Optional context name to switch to\n */\nexport function getNetworkingApi(contextName?: string): k8s.NetworkingV1Api {\n  // Always reinitialize for AWS EKS to refresh tokens\n  initK8sClient(contextName)\n  return k8sNetworkingApi!\n}\n\n/**\n * Get Batch V1 API client (for Jobs, CronJobs)\n * @param contextName - Optional context name to switch to\n */\nexport function getBatchApi(contextName?: string): k8s.BatchV1Api {\n  // Always reinitialize for AWS EKS to refresh tokens\n  initK8sClient(contextName)\n  return k8sBatchApi!\n}\n\n/**\n * Get KubeConfig instance\n */\nexport function getKubeConfig(): k8s.KubeConfig {\n  if (!kc) {\n    initK8sClient()\n  }\n  return kc!\n}\n\n/**\n * Check if client is initialized and can connect to cluster\n */\nexport async function checkConnection(): Promise<boolean> {\n  try {\n    const coreApi = getCoreApi()\n    await coreApi.listNamespace()\n    return true\n  } catch (error) {\n    console.error('[K8s] Connection check failed:', error)\n    return false\n  }\n}\n\n/**\n * Reset client (useful for testing or reconnecting)\n */\nexport function resetClient(): void {\n  kc = null\n  k8sAppsApi = null\n  k8sCoreApi = null\n  k8sAutoscalingApi = null\n  k8sEventsApi = null\n  k8sNetworkingApi = null\n  k8sBatchApi = null\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;CAQC;;;;;;;;;;;;;;;;;;;;;;AAED;AAAA;AAAA;;AAEA,IAAI,KAA4B;AAChC,IAAI,aAAmC;AACvC,IAAI,aAAmC;AACvC,IAAI,oBAAiD;AACrD,IAAI,eAAuC;AAC3C,IAAI,mBAA+C;AACnD,IAAI,cAAqC;AASlC,SAAS,cAAc,WAAoB;IAChD,8DAA8D;IAC9D,KAAK,IAAI,gLAAc;IAEvB,8DAA8D;IAC9D,mEAAmE;IACnE,IAAI;QACF,6CAA6C;QAC7C,GAAG,eAAe;QAElB,0CAA0C;QAC1C,IAAI,aAAa;YACf,GAAG,iBAAiB,CAAC;QACvB;QAEA,MAAM,UAAU,GAAG,iBAAiB;QACpC,MAAM,aAAa,GAAG,iBAAiB;QAEvC,iCAAiC;QACjC,IAAI,CAAC,SAAS,QAAQ;YACpB,MAAM,IAAI,MAAM,CAAC,kDAAkD,EAAE,eAAe,YAAY;QAClG;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,kDAAkD;QAChE,MAAM,IAAI,MAAM;IAClB;IAEA,mEAAmE;IACnE,aAAa,GAAG,aAAa,CAAC,qLAAa;IAC3C,aAAa,GAAG,aAAa,CAAC,qLAAa;IAC3C,oBAAoB,GAAG,aAAa,CAAC,4LAAoB;IACzD,eAAe,GAAG,aAAa,CAAC,uLAAe;IAC/C,mBAAmB,GAAG,aAAa,CAAC,2LAAmB;IACvD,cAAc,GAAG,aAAa,CAAC,sLAAc;AAC/C;AAMO,SAAS,WAAW,WAAoB;IAC7C,oDAAoD;IACpD,cAAc;IACd,OAAO;AACT;AAMO,SAAS,WAAW,WAAoB;IAC7C,oDAAoD;IACpD,cAAc;IACd,OAAO;AACT;AAMO,SAAS,kBAAkB,WAAoB;IACpD,oDAAoD;IACpD,cAAc;IACd,OAAO;AACT;AAMO,SAAS,aAAa,WAAoB;IAC/C,oDAAoD;IACpD,cAAc;IACd,OAAO;AACT;AAMO,SAAS,iBAAiB,WAAoB;IACnD,oDAAoD;IACpD,cAAc;IACd,OAAO;AACT;AAMO,SAAS,YAAY,WAAoB;IAC9C,oDAAoD;IACpD,cAAc;IACd,OAAO;AACT;AAKO,SAAS;IACd,IAAI,CAAC,IAAI;QACP;IACF;IACA,OAAO;AACT;AAKO,eAAe;IACpB,IAAI;QACF,MAAM,UAAU;QAChB,MAAM,QAAQ,aAAa;QAC3B,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,kCAAkC;QAChD,OAAO;IACT;AACF;AAKO,SAAS;IACd,KAAK;IACL,aAAa;IACb,aAAa;IACb,oBAAoB;IACpB,eAAe;IACf,mBAAmB;IACnB,cAAc;AAChB"}},
    {"offset": {"line": 338, "column": 0}, "map": {"version":3,"sources":["file:///Users/dmakowski/git_priv/kubevista/app/api/cluster/health/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server'\nimport { getCoreApi } from '@/lib/k8s/client'\n\nexport const dynamic = 'force-dynamic'\n\nexport async function GET() {\n  try {\n    const coreV1Api = getCoreApi()\n\n    // Try to list namespaces as a health check\n    // This is a lightweight operation that requires basic cluster access\n    await coreV1Api.listNamespace()\n\n    return NextResponse.json({\n      status: 'connected',\n      message: 'Successfully connected to Kubernetes cluster',\n    })\n  } catch (error: unknown) {\n    console.error('[Health Check] Cluster connection failed:', error)\n\n    const err = error as { code?: number; message?: string; body?: { message?: string } }\n    const statusCode = err.code || 500\n    const message = err.body?.message || err.message || 'Unknown error'\n\n    // Return specific error information\n    return NextResponse.json(\n      {\n        status: 'disconnected',\n        message:\n          statusCode === 401\n            ? 'Unauthorized: Invalid or expired cluster credentials'\n            : statusCode === 403\n              ? 'Forbidden: Insufficient permissions to access cluster'\n              : statusCode === 404\n                ? 'Cluster not found: Check your kubeconfig'\n                : `Failed to connect to cluster: ${message}`,\n        code: statusCode,\n      },\n      { status: 200 } // Return 200 so the client can handle the disconnected state\n    )\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAEO,MAAM,UAAU;AAEhB,eAAe;IACpB,IAAI;QACF,MAAM,YAAY,IAAA,oIAAU;QAE5B,2CAA2C;QAC3C,qEAAqE;QACrE,MAAM,UAAU,aAAa;QAE7B,OAAO,gJAAY,CAAC,IAAI,CAAC;YACvB,QAAQ;YACR,SAAS;QACX;IACF,EAAE,OAAO,OAAgB;QACvB,QAAQ,KAAK,CAAC,6CAA6C;QAE3D,MAAM,MAAM;QACZ,MAAM,aAAa,IAAI,IAAI,IAAI;QAC/B,MAAM,UAAU,IAAI,IAAI,EAAE,WAAW,IAAI,OAAO,IAAI;QAEpD,oCAAoC;QACpC,OAAO,gJAAY,CAAC,IAAI,CACtB;YACE,QAAQ;YACR,SACE,eAAe,MACX,yDACA,eAAe,MACb,0DACA,eAAe,MACb,6CACA,CAAC,8BAA8B,EAAE,SAAS;YACpD,MAAM;QACR,GACA;YAAE,QAAQ;QAAI,EAAE,6DAA6D;;IAEjF;AACF"}}]
}