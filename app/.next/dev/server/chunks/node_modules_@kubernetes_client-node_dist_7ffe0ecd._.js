module.exports = [
"[project]/node_modules/@kubernetes/client-node/dist/azure_auth.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AzureAuth",
    ()=>AzureAuth
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$child_process__$5b$external$5d$__$28$node$3a$child_process$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:child_process [external] (node:child_process, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jsonpath$2d$plus$2f$dist$2f$index$2d$node$2d$esm$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/jsonpath-plus/dist/index-node-esm.js [app-route] (ecmascript)");
;
;
class AzureAuth {
    isAuthProvider(user) {
        if (!user || !user.authProvider) {
            return false;
        }
        return user.authProvider.name === 'azure';
    }
    async applyAuthentication(user, opts) {
        const token = this.getToken(user);
        if (token) {
            opts.headers['Authorization'] = `Bearer ${token}`;
        }
    }
    getToken(user) {
        const config = user.authProvider.config;
        if (this.isExpired(config)) {
            this.updateAccessToken(config);
        }
        return config['access-token'];
    }
    isExpired(config) {
        const token = config['access-token'];
        const expiry = config.expiry;
        const expiresOn = config['expires-on'];
        if (!token) {
            return true;
        }
        if (!expiry && !expiresOn) {
            return false;
        }
        const expiresOnDate = expiresOn ? new Date(parseInt(expiresOn, 10) * 1000) : undefined;
        const expiration = expiry ? Date.parse(expiry) : expiresOnDate.getTime();
        if (expiration < Date.now()) {
            return true;
        }
        return false;
    }
    updateAccessToken(config) {
        let cmd = config['cmd-path'];
        if (!cmd) {
            throw new Error('Token is expired!');
        }
        // Wrap cmd in quotes to make it cope with spaces in path
        cmd = `"${cmd}"`;
        const args = config['cmd-args'];
        if (args) {
            cmd = cmd + ' ' + args;
        }
        // TODO: Cache to file?
        // TODO: do this asynchronously
        let output;
        try {
            output = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$child_process__$5b$external$5d$__$28$node$3a$child_process$2c$__cjs$29$__["default"].execSync(cmd);
        } catch (err) {
            throw new Error('Failed to refresh token: ' + err);
        }
        const resultObj = JSON.parse(output);
        const tokenPathKeyInConfig = config['token-key'];
        const expiryPathKeyInConfig = config['expiry-key'];
        // Format in file is {<query>}, so slice it out and add '$'
        const tokenPathKey = '$' + tokenPathKeyInConfig.slice(1, -1);
        const expiryPathKey = '$' + expiryPathKeyInConfig.slice(1, -1);
        config['access-token'] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jsonpath$2d$plus$2f$dist$2f$index$2d$node$2d$esm$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["JSONPath"]({
            path: tokenPathKey,
            json: resultObj
        });
        config.expiry = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jsonpath$2d$plus$2f$dist$2f$index$2d$node$2d$esm$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["JSONPath"]({
            path: expiryPathKey,
            json: resultObj
        });
    }
} //# sourceMappingURL=azure_auth.js.map
}),
"[project]/node_modules/@kubernetes/client-node/dist/config_types.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ActionOnInvalid",
    ()=>ActionOnInvalid,
    "exportCluster",
    ()=>exportCluster,
    "exportContext",
    ()=>exportContext,
    "exportUser",
    ()=>exportUser,
    "newClusters",
    ()=>newClusters,
    "newContexts",
    ()=>newContexts,
    "newUsers",
    ()=>newUsers
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs [external] (node:fs, cjs)");
;
const ActionOnInvalid = {
    THROW: 'throw',
    FILTER: 'filter'
};
function defaultNewConfigOptions() {
    return {
        onInvalidEntry: ActionOnInvalid.THROW
    };
}
function newClusters(a, opts) {
    if (!Array.isArray(a)) {
        return [];
    }
    const options = Object.assign(defaultNewConfigOptions(), opts || {});
    return a.map(clusterIterator(options.onInvalidEntry)).filter(Boolean);
}
function exportCluster(cluster) {
    return {
        name: cluster.name,
        cluster: {
            server: cluster.server,
            'certificate-authority-data': cluster.caData,
            'certificate-authority': cluster.caFile,
            'insecure-skip-tls-verify': cluster.skipTLSVerify,
            'tls-server-name': cluster.tlsServerName,
            'proxy-url': cluster.proxyUrl
        }
    };
}
function clusterIterator(onInvalidEntry) {
    return (elt, i, list)=>{
        try {
            if (!elt.name) {
                throw new Error(`clusters[${i}].name is missing`);
            }
            if (!elt.cluster) {
                throw new Error(`clusters[${i}].cluster is missing`);
            }
            if (!elt.cluster.server) {
                throw new Error(`clusters[${i}].cluster.server is missing`);
            }
            return {
                caData: elt.cluster['certificate-authority-data'],
                caFile: elt.cluster['certificate-authority'],
                name: elt.name,
                server: elt.cluster.server.replace(/\/$/, ''),
                skipTLSVerify: elt.cluster['insecure-skip-tls-verify'] === true,
                tlsServerName: elt.cluster['tls-server-name'],
                proxyUrl: elt.cluster['proxy-url']
            };
        } catch (err) {
            switch(onInvalidEntry){
                case ActionOnInvalid.FILTER:
                    return null;
                default:
                case ActionOnInvalid.THROW:
                    throw err;
            }
        }
    };
}
function newUsers(a, opts) {
    if (!Array.isArray(a)) {
        return [];
    }
    const options = Object.assign(defaultNewConfigOptions(), opts || {});
    return a.map(userIterator(options.onInvalidEntry)).filter(Boolean);
}
function exportUser(user) {
    return {
        name: user.name,
        user: {
            as: user.impersonateUser,
            'auth-provider': user.authProvider,
            'client-certificate-data': user.certData,
            'client-certificate': user.certFile,
            exec: user.exec,
            'client-key-data': user.keyData,
            'client-key': user.keyFile,
            token: user.token,
            password: user.password,
            username: user.username
        }
    };
}
function userIterator(onInvalidEntry) {
    return (elt, i, list)=>{
        try {
            if (!elt.name) {
                throw new Error(`users[${i}].name is missing`);
            }
            return {
                authProvider: elt.user ? elt.user['auth-provider'] : null,
                certData: elt.user ? elt.user['client-certificate-data'] : null,
                certFile: elt.user ? elt.user['client-certificate'] : null,
                exec: elt.user ? elt.user.exec : null,
                keyData: elt.user ? elt.user['client-key-data'] : null,
                keyFile: elt.user ? elt.user['client-key'] : null,
                name: elt.name,
                token: findToken(elt.user),
                password: elt.user ? elt.user.password : null,
                username: elt.user ? elt.user.username : null,
                impersonateUser: elt.user ? elt.user.as : null
            };
        } catch (err) {
            switch(onInvalidEntry){
                case ActionOnInvalid.FILTER:
                    return null;
                default:
                case ActionOnInvalid.THROW:
                    throw err;
            }
        }
    };
}
function findToken(user) {
    if (user) {
        if (user.token) {
            return user.token;
        }
        if (user['token-file']) {
            return __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["default"].readFileSync(user['token-file']).toString();
        }
    }
}
function newContexts(a, opts) {
    if (!Array.isArray(a)) {
        return [];
    }
    const options = Object.assign(defaultNewConfigOptions(), opts || {});
    return a.map(contextIterator(options.onInvalidEntry)).filter(Boolean);
}
function exportContext(ctx) {
    return {
        name: ctx.name,
        context: ctx
    };
}
function contextIterator(onInvalidEntry) {
    return (elt, i, list)=>{
        try {
            if (!elt.name) {
                throw new Error(`contexts[${i}].name is missing`);
            }
            if (!elt.context) {
                throw new Error(`contexts[${i}].context is missing`);
            }
            if (!elt.context.cluster) {
                throw new Error(`contexts[${i}].context.cluster is missing`);
            }
            return {
                cluster: elt.context.cluster,
                name: elt.name,
                user: elt.context.user || undefined,
                namespace: elt.context.namespace || undefined
            };
        } catch (err) {
            switch(onInvalidEntry){
                case ActionOnInvalid.FILTER:
                    return null;
                default:
                case ActionOnInvalid.THROW:
                    throw err;
            }
        }
    };
} //# sourceMappingURL=config_types.js.map
}),
"[project]/node_modules/@kubernetes/client-node/dist/exec_auth.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ExecAuth",
    ()=>ExecAuth
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$child_process__$5b$external$5d$__$28$node$3a$child_process$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:child_process [external] (node:child_process, cjs)");
;
class ExecAuth {
    constructor(){
        this.tokenCache = {};
        this.execFn = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$child_process__$5b$external$5d$__$28$node$3a$child_process$2c$__cjs$29$__["default"].spawn;
    }
    isAuthProvider(user) {
        if (!user) {
            return false;
        }
        if (user.exec) {
            return true;
        }
        if (!user.authProvider) {
            return false;
        }
        return user.authProvider.name === 'exec' || !!(user.authProvider.config && user.authProvider.config.exec);
    }
    async applyAuthentication(user, opts) {
        const credential = await this.getCredential(user);
        if (!credential) {
            return;
        }
        if (credential.status.clientCertificateData) {
            opts.cert = credential.status.clientCertificateData;
        }
        if (credential.status.clientKeyData) {
            opts.key = credential.status.clientKeyData;
        }
        const token = this.getToken(credential);
        if (token) {
            if (!opts.headers) {
                opts.headers = {};
            }
            opts.headers['Authorization'] = `Bearer ${token}`;
        }
    }
    getToken(credential) {
        if (!credential) {
            return null;
        }
        if (credential.status.token) {
            return credential.status.token;
        }
        return null;
    }
    async getCredential(user) {
        // TODO: Add a unit test for token caching.
        const cachedToken = this.tokenCache[user.name];
        if (cachedToken) {
            const date = Date.parse(cachedToken.status.expirationTimestamp);
            if (date > Date.now()) {
                return cachedToken;
            }
            this.tokenCache[user.name] = null;
        }
        let exec = null;
        if (user.authProvider && user.authProvider.config) {
            exec = user.authProvider.config.exec;
        }
        if (user.exec) {
            exec = user.exec;
        }
        if (!exec) {
            return null;
        }
        if (!exec.command) {
            throw new Error('No command was specified for exec authProvider!');
        }
        let opts = {};
        if (exec.env) {
            const env = {
                ...process.env
            };
            exec.env.forEach((elt)=>env[elt.name] = elt.value);
            opts = {
                ...opts,
                env
            };
        }
        return new Promise((resolve, reject)=>{
            let stdoutData = '';
            let stderrData = '';
            let savedError = undefined;
            const subprocess = this.execFn(exec.command, exec.args, opts);
            subprocess.stdout.setEncoding('utf8');
            subprocess.stderr.setEncoding('utf8');
            subprocess.stdout.on('data', (data)=>{
                stdoutData += data;
            });
            subprocess.stderr.on('data', (data)=>{
                stderrData += data;
            });
            subprocess.on('error', (error)=>{
                savedError = error;
            });
            subprocess.on('close', (code)=>{
                if (savedError) {
                    reject(savedError);
                    return;
                }
                if (code !== 0) {
                    reject(new Error(stderrData));
                    return;
                }
                try {
                    const obj = JSON.parse(stdoutData);
                    this.tokenCache[user.name] = obj;
                    resolve(obj);
                } catch (error) {
                    reject(error);
                }
            });
        });
    }
} //# sourceMappingURL=exec_auth.js.map
}),
"[project]/node_modules/@kubernetes/client-node/dist/file_auth.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "FileAuth",
    ()=>FileAuth
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs [external] (node:fs, cjs)");
;
class FileAuth {
    constructor(){
        this.token = null;
        this.lastRead = null;
    }
    isAuthProvider(user) {
        return user.authProvider && user.authProvider.config && user.authProvider.config.tokenFile;
    }
    async applyAuthentication(user, opts) {
        if (this.token == null) {
            this.refreshToken(user.authProvider.config.tokenFile);
        }
        if (this.isTokenExpired()) {
            this.refreshToken(user.authProvider.config.tokenFile);
        }
        if (this.token) {
            opts.headers['Authorization'] = `Bearer ${this.token}`;
        }
    }
    refreshToken(filePath) {
        // TODO make this async?
        this.token = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["default"].readFileSync(filePath).toString('utf-8');
        this.lastRead = new Date();
    }
    isTokenExpired() {
        if (this.lastRead === null) {
            return true;
        }
        const now = new Date();
        const delta = (now.getTime() - this.lastRead.getTime()) / 1000;
        // For now just refresh every 60 seconds. This is imperfect since the token
        // could be out of date for this time, but it is unlikely and it's also what
        // the client-go library does.
        // TODO: Use file notifications instead?
        return delta > 60;
    }
} //# sourceMappingURL=file_auth.js.map
}),
"[project]/node_modules/@kubernetes/client-node/dist/gcp_auth.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GoogleCloudPlatformAuth",
    ()=>GoogleCloudPlatformAuth
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$child_process__$5b$external$5d$__$28$node$3a$child_process$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:child_process [external] (node:child_process, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jsonpath$2d$plus$2f$dist$2f$index$2d$node$2d$esm$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/jsonpath-plus/dist/index-node-esm.js [app-route] (ecmascript)");
;
;
class GoogleCloudPlatformAuth {
    isAuthProvider(user) {
        if (!user || !user.authProvider) {
            return false;
        }
        return user.authProvider.name === 'gcp';
    }
    async applyAuthentication(user, opts) {
        const token = this.getToken(user);
        if (token) {
            opts.headers['Authorization'] = `Bearer ${token}`;
        }
    }
    getToken(user) {
        const config = user.authProvider.config;
        if (this.isExpired(config)) {
            this.updateAccessToken(config);
        }
        return config['access-token'];
    }
    isExpired(config) {
        const token = config['access-token'];
        const expiry = config.expiry;
        if (!token) {
            return true;
        }
        if (!expiry) {
            return false;
        }
        const expiration = Date.parse(expiry);
        if (expiration < Date.now()) {
            return true;
        }
        return false;
    }
    updateAccessToken(config) {
        let cmd = config['cmd-path'];
        if (!cmd) {
            throw new Error('Token is expired!');
        }
        // Wrap cmd in quotes to make it cope with spaces in path
        cmd = `"${cmd}"`;
        const args = config['cmd-args'];
        if (args) {
            cmd = cmd + ' ' + args;
        }
        // TODO: Cache to file?
        // TODO: do this asynchronously
        let output;
        try {
            output = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$child_process__$5b$external$5d$__$28$node$3a$child_process$2c$__cjs$29$__["default"].execSync(cmd);
        } catch (err) {
            throw new Error('Failed to refresh token: ' + err);
        }
        const resultObj = JSON.parse(output);
        const tokenPathKeyInConfig = config['token-key'];
        const expiryPathKeyInConfig = config['expiry-key'];
        // Format in file is {<query>}, so slice it out and add '$'
        const tokenPathKey = '$' + tokenPathKeyInConfig.slice(1, -1);
        const expiryPathKey = '$' + expiryPathKeyInConfig.slice(1, -1);
        config['access-token'] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jsonpath$2d$plus$2f$dist$2f$index$2d$node$2d$esm$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["JSONPath"]({
            path: tokenPathKey,
            json: resultObj
        });
        config.expiry = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$jsonpath$2d$plus$2f$dist$2f$index$2d$node$2d$esm$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["JSONPath"]({
            path: expiryPathKey,
            json: resultObj
        });
    }
} //# sourceMappingURL=gcp_auth.js.map
}),
"[project]/node_modules/@kubernetes/client-node/dist/oidc_auth.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "OpenIDConnectAuth",
    ()=>OpenIDConnectAuth
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openid$2d$client$2f$build$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/openid-client/build/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rfc4648$2f$lib$2f$rfc4648$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/rfc4648/lib/rfc4648.js [app-route] (ecmascript)");
;
;
class OidcClient {
    constructor(c){
        this.config = c;
    }
    async refresh(token) {
        const newToken = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openid$2d$client$2f$build$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["refreshTokenGrant"](this.config, token);
        return {
            id_token: newToken.id_token,
            refresh_token: newToken.refresh_token,
            expires_at: newToken.expiresIn()
        };
    }
}
class OpenIDConnectAuth {
    constructor(){
        // public for testing purposes.
        this.currentTokenExpiration = 0;
    }
    static decodeJWT(token) {
        const parts = token.split('.');
        if (parts.length !== 3) {
            return null;
        }
        const header = JSON.parse(new TextDecoder().decode(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rfc4648$2f$lib$2f$rfc4648$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["base64url"].parse(parts[0], {
            loose: true
        })));
        const payload = JSON.parse(new TextDecoder().decode(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$rfc4648$2f$lib$2f$rfc4648$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["base64url"].parse(parts[1], {
            loose: true
        })));
        const signature = parts[2];
        return {
            header,
            payload,
            signature
        };
    }
    static expirationFromToken(token) {
        const jwt = OpenIDConnectAuth.decodeJWT(token);
        if (!jwt) {
            return 0;
        }
        return jwt.payload.exp;
    }
    isAuthProvider(user) {
        if (!user.authProvider) {
            return false;
        }
        return user.authProvider.name === 'oidc';
    }
    /**
     * Setup the authentication header for oidc authed clients
     * @param user user info
     * @param opts request options
     * @param overrideClient for testing, a preconfigured oidc client
     */ async applyAuthentication(user, opts, overrideClient) {
        const token = await this.getToken(user, overrideClient);
        if (token) {
            opts.headers['Authorization'] = `Bearer ${token}`;
        }
    }
    async getToken(user, overrideClient) {
        if (!user.authProvider.config) {
            return null;
        }
        if (!user.authProvider.config['client-secret']) {
            user.authProvider.config['client-secret'] = '';
        }
        if (!user.authProvider.config || !user.authProvider.config['id-token']) {
            return null;
        }
        return this.refresh(user, overrideClient);
    }
    async refresh(user, overrideClient) {
        if (this.currentTokenExpiration === 0) {
            this.currentTokenExpiration = OpenIDConnectAuth.expirationFromToken(user.authProvider.config['id-token']);
        }
        if (Date.now() / 1000 > this.currentTokenExpiration) {
            if (!user.authProvider.config['client-id'] || !user.authProvider.config['refresh-token'] || !user.authProvider.config['idp-issuer-url']) {
                return null;
            }
            const client = overrideClient ? overrideClient : await this.getClient(user);
            const newToken = await client.refresh(user.authProvider.config['refresh-token']);
            user.authProvider.config['id-token'] = newToken.id_token;
            user.authProvider.config['refresh-token'] = newToken.refresh_token;
            this.currentTokenExpiration = newToken.expires_at;
        }
        return user.authProvider.config['id-token'];
    }
    async getClient(user) {
        const configuration = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$openid$2d$client$2f$build$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["discovery"](user.authProvider.config['idp-issuer-url'], user.authProvider.config['client-id']);
        return new OidcClient(configuration);
    }
} //# sourceMappingURL=oidc_auth.js.map
}),
"[project]/node_modules/@kubernetes/client-node/dist/config.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "KubeConfig",
    ()=>KubeConfig,
    "bufferFromFileOrString",
    ()=>bufferFromFileOrString,
    "findHomeDir",
    ()=>findHomeDir,
    "findObject",
    ()=>findObject,
    "makeAbsolutePath",
    ()=>makeAbsolutePath
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:fs [external] (node:fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$https__$5b$external$5d$__$28$node$3a$https$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:https [external] (node:https, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$http__$5b$external$5d$__$28$node$3a$http$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:http [external] (node:http, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$js$2d$yaml$2f$dist$2f$js$2d$yaml$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/js-yaml/dist/js-yaml.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$net__$5b$external$5d$__$28$node$3a$net$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:net [external] (node:net, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:path [external] (node:path, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/lib/index.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$azure_auth$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/azure_auth.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$config_types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/config_types.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$exec_auth$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/exec_auth.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$file_auth$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/file_auth.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gcp_auth$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/gcp_auth.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/gen/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$configuration$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/gen/configuration.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$servers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/gen/servers.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$oidc_auth$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/oidc_auth.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$child_process__$5b$external$5d$__$28$node$3a$child_process$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:child_process [external] (node:child_process, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socks$2d$proxy$2d$agent$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/socks-proxy-agent/dist/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hpagent$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/hpagent/index.mjs [app-route] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
const SERVICEACCOUNT_ROOT = '/var/run/secrets/kubernetes.io/serviceaccount';
const SERVICEACCOUNT_CA_PATH = SERVICEACCOUNT_ROOT + '/ca.crt';
const SERVICEACCOUNT_TOKEN_PATH = SERVICEACCOUNT_ROOT + '/token';
const SERVICEACCOUNT_NAMESPACE_PATH = SERVICEACCOUNT_ROOT + '/namespace';
// fs.existsSync was removed in node 10
function fileExists(filepath) {
    try {
        __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["default"].accessSync(filepath);
        return true;
    } catch  {
        // Ignore errors.
        return false;
    }
}
class KubeConfig {
    // Optionally add additional external authenticators, you must do this
    // before you load a kubeconfig file that references them.
    addAuthenticator(authenticator) {
        this.custom_authenticators.push(authenticator);
    }
    constructor(){
        this.authenticators = [
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$azure_auth$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AzureAuth"](),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gcp_auth$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["GoogleCloudPlatformAuth"](),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$exec_auth$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExecAuth"](),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$file_auth$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["FileAuth"](),
            new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$oidc_auth$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["OpenIDConnectAuth"]()
        ];
        // List of custom authenticators that can be added by the user
        this.custom_authenticators = [];
        this.contexts = [];
        this.clusters = [];
        this.users = [];
    }
    getContexts() {
        return this.contexts;
    }
    getClusters() {
        return this.clusters;
    }
    getUsers() {
        return this.users;
    }
    getCurrentContext() {
        return this.currentContext;
    }
    setCurrentContext(context) {
        this.currentContext = context;
    }
    getContextObject(name) {
        if (!this.contexts) {
            return null;
        }
        return findObject(this.contexts, name, 'context');
    }
    getCurrentCluster() {
        const context = this.getCurrentContextObject();
        if (!context) {
            return null;
        }
        return this.getCluster(context.cluster);
    }
    getCluster(name) {
        return findObject(this.clusters, name, 'cluster');
    }
    getCurrentUser() {
        const ctx = this.getCurrentContextObject();
        if (!ctx) {
            return null;
        }
        return this.getUser(ctx.user);
    }
    getUser(name) {
        return findObject(this.users, name, 'user');
    }
    loadFromFile(file, opts) {
        const rootDirectory = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].dirname(file);
        this.loadFromString(__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["default"].readFileSync(file).toString('utf-8'), opts);
        this.makePathsAbsolute(rootDirectory);
    }
    async applyToFetchOptions(opts) {
        await this.applyToHTTPSOptions(opts);
        const headers = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Headers"]();
        for (const [key, val] of Object.entries(opts.headers || {})){
            if (Array.isArray(val)) {
                val.forEach((innerVal)=>{
                    headers.append(key, innerVal);
                });
            } else if (typeof val === 'number' || typeof val === 'string') {
                headers.set(key, val.toString());
            }
        }
        if (opts.auth) {
            headers.set('Authorization', 'Basic ' + Buffer.from(opts.auth).toString('base64'));
        }
        return {
            agent: opts.agent,
            headers,
            method: opts.method,
            timeout: opts.timeout
        };
    }
    async applyToHTTPSOptions(opts) {
        const user = this.getCurrentUser();
        const cluster = this.getCurrentCluster();
        await this.applyOptions(opts);
        if (user && user.username) {
            // The ws docs say that it accepts anything that https.RequestOptions accepts,
            // but Typescript doesn't understand that idea (yet) probably could be fixed in
            // the typings, but for now just cast to any
            opts.auth = `${user.username}:${user.password}`;
        }
        const agentOptions = {};
        // Copy AgentOptions from RequestOptions
        agentOptions.ca = opts.ca;
        agentOptions.cert = opts.cert;
        agentOptions.key = opts.key;
        agentOptions.pfx = opts.pfx;
        agentOptions.passphrase = opts.passphrase;
        // Only set rejectUnauthorized if explicitly configured. When not set, fetch will use NODE_TLS_REJECT_UNAUTHORIZED env var
        if (opts.rejectUnauthorized !== undefined) {
            agentOptions.rejectUnauthorized = opts.rejectUnauthorized;
        }
        // The ws docs say that it accepts anything that https.RequestOptions accepts,
        // but Typescript doesn't understand that idea (yet) probably could be fixed in
        // the typings, but for now just cast to any
        agentOptions.timeout = opts.timeout;
        agentOptions.servername = opts.servername;
        agentOptions.ciphers = opts.ciphers;
        agentOptions.honorCipherOrder = opts.honorCipherOrder;
        agentOptions.ecdhCurve = opts.ecdhCurve;
        agentOptions.clientCertEngine = opts.clientCertEngine;
        agentOptions.crl = opts.crl;
        agentOptions.dhparam = opts.dhparam;
        agentOptions.secureOptions = opts.secureOptions;
        agentOptions.secureProtocol = opts.secureProtocol;
        agentOptions.sessionIdContext = opts.sessionIdContext;
        opts.agent = this.createAgent(cluster, agentOptions);
    }
    /**
     * Applies SecurityAuthentication to RequestContext of an API Call from API Client
     * @param context
     */ async applySecurityAuthentication(context) {
        const cluster = this.getCurrentCluster();
        const user = this.getCurrentUser();
        const agentOptions = {};
        const httpsOptions = {};
        await this.applyOptions(httpsOptions);
        if (cluster && cluster.skipTLSVerify) {
            agentOptions.rejectUnauthorized = false;
        }
        if (cluster && cluster.tlsServerName) {
            agentOptions.servername = cluster.tlsServerName;
        }
        if (user && user.username) {
            const auth = Buffer.from(`${user.username}:${user.password}`).toString('base64');
            context.setHeaderParam('Authorization', `Basic ${auth}`);
        }
        // Copy headers from httpsOptions to RequestContext
        const headers = httpsOptions.headers || {};
        Object.entries(headers).forEach(([key, value])=>{
            context.setHeaderParam(key, `${value}`);
        });
        // Copy AgentOptions from RequestOptions
        agentOptions.ca = httpsOptions.ca;
        agentOptions.cert = httpsOptions.cert;
        agentOptions.key = httpsOptions.key;
        agentOptions.pfx = httpsOptions.pfx;
        agentOptions.passphrase = httpsOptions.passphrase;
        // Only set rejectUnauthorized if explicitly configured. When not set, fetch will use NODE_TLS_REJECT_UNAUTHORIZED env var
        if (httpsOptions.rejectUnauthorized !== undefined) {
            agentOptions.rejectUnauthorized = httpsOptions.rejectUnauthorized;
        }
        context.setAgent(this.createAgent(cluster, agentOptions));
    }
    /**
     * Returns name of this security authentication method
     * @returns string
     */ getName() {
        return 'kubeconfig authentication';
    }
    loadFromString(config, opts) {
        const obj = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$js$2d$yaml$2f$dist$2f$js$2d$yaml$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].load(config);
        this.clusters = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$config_types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["newClusters"])(obj.clusters, opts);
        this.contexts = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$config_types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["newContexts"])(obj.contexts, opts);
        this.users = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$config_types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["newUsers"])(obj.users, opts);
        this.currentContext = obj['current-context'];
    }
    loadFromOptions(options) {
        this.clusters = options.clusters;
        this.contexts = options.contexts;
        this.users = options.users;
        this.currentContext = options.currentContext;
    }
    loadFromClusterAndUser(cluster, user) {
        this.clusters = [
            cluster
        ];
        this.users = [
            user
        ];
        this.currentContext = 'loaded-context';
        this.contexts = [
            {
                cluster: cluster.name,
                user: user.name,
                name: this.currentContext
            }
        ];
    }
    loadFromCluster(pathPrefix = '') {
        const host = process.env.KUBERNETES_SERVICE_HOST;
        const port = process.env.KUBERNETES_SERVICE_PORT;
        const clusterName = 'inCluster';
        const userName = 'inClusterUser';
        const contextName = 'inClusterContext';
        let scheme = 'https';
        if (port === '80' || port === '8080' || port === '8001') {
            scheme = 'http';
        }
        // Wrap raw IPv6 addresses in brackets.
        let serverHost = host;
        if (host && __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$net__$5b$external$5d$__$28$node$3a$net$2c$__cjs$29$__["default"].isIPv6(host)) {
            serverHost = `[${host}]`;
        }
        this.clusters = [
            {
                name: clusterName,
                caFile: `${pathPrefix}${SERVICEACCOUNT_CA_PATH}`,
                server: `${scheme}://${serverHost}:${port}`,
                skipTLSVerify: false
            }
        ];
        this.users = [
            {
                name: userName,
                authProvider: {
                    name: 'tokenFile',
                    config: {
                        tokenFile: `${pathPrefix}${SERVICEACCOUNT_TOKEN_PATH}`
                    }
                }
            }
        ];
        const namespaceFile = `${pathPrefix}${SERVICEACCOUNT_NAMESPACE_PATH}`;
        let namespace;
        if (fileExists(namespaceFile)) {
            namespace = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["default"].readFileSync(namespaceFile).toString('utf-8');
        }
        this.contexts = [
            {
                cluster: clusterName,
                name: contextName,
                user: userName,
                namespace
            }
        ];
        this.currentContext = contextName;
    }
    mergeConfig(config, preserveContext = false) {
        if (!preserveContext && config.currentContext) {
            this.currentContext = config.currentContext;
        }
        config.clusters.forEach((cluster)=>{
            this.addCluster(cluster);
        });
        config.users.forEach((user)=>{
            this.addUser(user);
        });
        config.contexts.forEach((ctx)=>{
            this.addContext(ctx);
        });
    }
    addCluster(cluster) {
        if (!this.clusters) {
            this.clusters = [];
        }
        this.clusters.forEach((c, ix)=>{
            if (c.name === cluster.name) {
                throw new Error(`Duplicate cluster: ${c.name}`);
            }
        });
        this.clusters.push(cluster);
    }
    addUser(user) {
        if (!this.users) {
            this.users = [];
        }
        this.users.forEach((c, ix)=>{
            if (c.name === user.name) {
                throw new Error(`Duplicate user: ${c.name}`);
            }
        });
        this.users.push(user);
    }
    addContext(ctx) {
        if (!this.contexts) {
            this.contexts = [];
        }
        this.contexts.forEach((c, ix)=>{
            if (c.name === ctx.name) {
                throw new Error(`Duplicate context: ${c.name}`);
            }
        });
        this.contexts.push(ctx);
    }
    loadFromDefault(opts, contextFromStartingConfig = false, platform = process.platform) {
        if (process.env.KUBECONFIG && process.env.KUBECONFIG.length > 0) {
            const files = process.env.KUBECONFIG.split(__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].delimiter).filter((filename)=>filename);
            this.loadFromFile(files[0], opts);
            for(let i = 1; i < files.length; i++){
                const kc = new KubeConfig();
                kc.loadFromFile(files[i], opts);
                this.mergeConfig(kc, contextFromStartingConfig);
            }
            return;
        }
        const home = findHomeDir(platform);
        if (home) {
            const config = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].join(home, '.kube', 'config');
            if (fileExists(config)) {
                this.loadFromFile(config, opts);
                return;
            }
        }
        if (platform === 'win32') {
            try {
                const envKubeconfigPathResult = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$child_process__$5b$external$5d$__$28$node$3a$child_process$2c$__cjs$29$__["default"].spawnSync('wsl.exe', [
                    'bash',
                    '-c',
                    'printenv KUBECONFIG'
                ]);
                if (envKubeconfigPathResult.status === 0 && envKubeconfigPathResult.stdout.length > 0) {
                    const result = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$child_process__$5b$external$5d$__$28$node$3a$child_process$2c$__cjs$29$__["default"].spawnSync('wsl.exe', [
                        'cat',
                        envKubeconfigPathResult.stdout.toString('utf8')
                    ]);
                    if (result.status === 0) {
                        this.loadFromString(result.stdout.toString('utf8'), opts);
                        return;
                    }
                }
            } catch  {
            // Falling back to default kubeconfig
            }
            try {
                const configResult = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$child_process__$5b$external$5d$__$28$node$3a$child_process$2c$__cjs$29$__["default"].spawnSync('wsl.exe', [
                    'cat',
                    '~/.kube/config'
                ]);
                if (configResult.status === 0) {
                    this.loadFromString(configResult.stdout.toString('utf8'), opts);
                    const result = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$child_process__$5b$external$5d$__$28$node$3a$child_process$2c$__cjs$29$__["default"].spawnSync('wsl.exe', [
                        'wslpath',
                        '-w',
                        '~/.kube'
                    ]);
                    if (result.status === 0) {
                        this.makePathsAbsolute(result.stdout.toString('utf8'));
                    }
                    return;
                }
            } catch  {
            // Falling back to alternative auth
            }
        }
        if (fileExists(SERVICEACCOUNT_TOKEN_PATH)) {
            this.loadFromCluster();
            return;
        }
        this.loadFromClusterAndUser({
            name: 'cluster',
            server: 'http://localhost:8080'
        }, {
            name: 'user'
        });
    }
    makeApiClient(apiClientType) {
        const cluster = this.getCurrentCluster();
        if (!cluster) {
            throw new Error('No active cluster!');
        }
        const authConfig = {
            default: this
        };
        const baseServerConfig = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$servers$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ServerConfiguration"](cluster.server, {});
        const config = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$configuration$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createConfiguration"])({
            baseServer: baseServerConfig,
            authMethods: authConfig
        });
        const apiClient = new apiClientType(config);
        return apiClient;
    }
    makePathsAbsolute(rootDirectory) {
        this.clusters.forEach((cluster)=>{
            if (cluster.caFile) {
                cluster.caFile = makeAbsolutePath(rootDirectory, cluster.caFile);
            }
        });
        this.users.forEach((user)=>{
            if (user.certFile) {
                user.certFile = makeAbsolutePath(rootDirectory, user.certFile);
            }
            if (user.keyFile) {
                user.keyFile = makeAbsolutePath(rootDirectory, user.keyFile);
            }
        });
    }
    exportConfig() {
        const configObj = {
            apiVersion: 'v1',
            kind: 'Config',
            clusters: this.clusters.map(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$config_types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["exportCluster"]),
            users: this.users.map(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$config_types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["exportUser"]),
            contexts: this.contexts.map(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$config_types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["exportContext"]),
            preferences: {},
            'current-context': this.getCurrentContext()
        };
        return JSON.stringify(configObj);
    }
    getCurrentContextObject() {
        return this.getContextObject(this.currentContext);
    }
    createAgent(cluster, agentOptions) {
        var _a, _b;
        let agent;
        if (cluster && cluster.proxyUrl) {
            if (cluster.proxyUrl.startsWith('socks')) {
                agent = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$socks$2d$proxy$2d$agent$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["SocksProxyAgent"](cluster.proxyUrl, agentOptions);
            } else if (cluster.server.startsWith('https')) {
                const httpsProxyAgentOptions = agentOptions;
                httpsProxyAgentOptions.proxy = cluster.proxyUrl;
                agent = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hpagent$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HttpsProxyAgent"](httpsProxyAgentOptions);
            } else if (cluster.server.startsWith('http')) {
                const httpProxyAgentOptions = agentOptions;
                httpProxyAgentOptions.proxy = cluster.proxyUrl;
                agent = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$hpagent$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HttpProxyAgent"](httpProxyAgentOptions);
            } else {
                throw new Error('Unsupported proxy type');
            }
        } else if (((_a = cluster === null || cluster === void 0 ? void 0 : cluster.server) === null || _a === void 0 ? void 0 : _a.startsWith('http:')) && cluster.skipTLSVerify) {
            agent = new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$http__$5b$external$5d$__$28$node$3a$http$2c$__cjs$29$__["default"].Agent(agentOptions);
        } else if (((_b = cluster === null || cluster === void 0 ? void 0 : cluster.server) === null || _b === void 0 ? void 0 : _b.startsWith('http:')) && !cluster.skipTLSVerify) {
            throw new Error('HTTP protocol is not allowed when skipTLSVerify is not set or false');
        } else {
            agent = new __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$https__$5b$external$5d$__$28$node$3a$https$2c$__cjs$29$__["default"].Agent(agentOptions);
        }
        return agent;
    }
    applyHTTPSOptions(opts) {
        var _a;
        const cluster = this.getCurrentCluster();
        const user = this.getCurrentUser();
        if (!user) {
            return;
        }
        if (cluster != null && cluster.skipTLSVerify) {
            opts.rejectUnauthorized = false;
        }
        if (cluster != null && cluster.tlsServerName) {
            // WebSocket.ClientOptions types are missing the servername
            opts.servername = cluster.tlsServerName;
        }
        const ca = cluster != null ? bufferFromFileOrString(cluster.caFile, cluster.caData) : null;
        if (ca) {
            opts.ca = ca;
        }
        const cert = bufferFromFileOrString(user.certFile, user.certData);
        if (cert) {
            opts.cert = cert;
        }
        const key = bufferFromFileOrString(user.keyFile, user.keyData);
        if (key) {
            opts.key = key;
        }
        if (user.impersonateUser != null) {
            (_a = opts.headers) !== null && _a !== void 0 ? _a : opts.headers = {};
            opts.headers['Impersonate-User'] = user.impersonateUser;
        }
    }
    async applyAuthorizationHeader(opts) {
        const user = this.getCurrentUser();
        if (!user) {
            return;
        }
        let authenticator = this.authenticators.find((elt)=>{
            return elt.isAuthProvider(user);
        });
        if (!authenticator) {
            authenticator = this.custom_authenticators.find((elt)=>{
                return elt.isAuthProvider(user);
            });
        }
        if (!opts.headers) {
            opts.headers = {};
        }
        if (authenticator) {
            await authenticator.applyAuthentication(user, opts);
        }
        if (user.token) {
            opts.headers.Authorization = `Bearer ${user.token}`;
        }
    }
    async applyOptions(opts) {
        this.applyHTTPSOptions(opts);
        await this.applyAuthorizationHeader(opts);
    }
}
function makeAbsolutePath(root, file) {
    if (!root || __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].isAbsolute(file)) {
        return file;
    }
    return __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].join(root, file);
}
function bufferFromFileOrString(file, data) {
    if (file) {
        return __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["default"].readFileSync(file);
    }
    if (data) {
        return Buffer.from(data, 'base64');
    }
    return null;
}
function dropDuplicatesAndNils(a) {
    return a.reduce((acceptedValues, currentValue)=>{
        // Good-enough algorithm for reducing a small (3 items at this point) array into an ordered list
        // of unique non-empty strings.
        if (currentValue && !acceptedValues.includes(currentValue)) {
            return acceptedValues.concat(currentValue);
        } else {
            return acceptedValues;
        }
    }, []);
}
function findHomeDir(platform = process.platform) {
    if (platform !== 'win32') {
        if (process.env.HOME) {
            try {
                __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["default"].accessSync(process.env.HOME);
                return process.env.HOME;
            } catch  {
            // Ignore errors.
            }
        }
        return null;
    }
    // $HOME is always favoured, but the k8s go-client prefers the other two env vars
    // differently depending on whether .kube/config exists or not.
    const homeDrivePath = process.env.HOMEDRIVE && process.env.HOMEPATH ? __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].join(process.env.HOMEDRIVE, process.env.HOMEPATH) : '';
    const homePath = process.env.HOME || '';
    const userProfile = process.env.USERPROFILE || '';
    const favourHomeDrivePathList = dropDuplicatesAndNils([
        homePath,
        homeDrivePath,
        userProfile
    ]);
    const favourUserProfileList = dropDuplicatesAndNils([
        homePath,
        userProfile,
        homeDrivePath
    ]);
    // 1. the first of %HOME%, %HOMEDRIVE%%HOMEPATH%, %USERPROFILE% containing a `.kube\config` file is returned.
    for (const dir of favourHomeDrivePathList){
        try {
            __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["default"].accessSync(__TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$path__$5b$external$5d$__$28$node$3a$path$2c$__cjs$29$__["default"].join(dir, '.kube', 'config'));
            return dir;
        } catch  {
        // Ignore errors.
        }
    }
    // 2. ...the first of %HOME%, %USERPROFILE%, %HOMEDRIVE%%HOMEPATH% that exists and is writeable is returned
    for (const dir of favourUserProfileList){
        try {
            __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["default"].accessSync(dir, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["default"].constants.W_OK);
            return dir;
        } catch  {
        // Ignore errors.
        }
    }
    // 3. ...the first of %HOME%, %USERPROFILE%, %HOMEDRIVE%%HOMEPATH% that exists is returned.
    for (const dir of favourUserProfileList){
        try {
            __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$fs__$5b$external$5d$__$28$node$3a$fs$2c$__cjs$29$__["default"].accessSync(dir);
            return dir;
        } catch  {
        // Ignore errors.
        }
    }
    // 4. if none of those locations exists, the first of
    // %HOME%, %USERPROFILE%, %HOMEDRIVE%%HOMEPATH% that is set is returned.
    return favourUserProfileList[0] || null;
}
function findObject(list, name, key) {
    if (!list) {
        return null;
    }
    for (const obj of list){
        if (obj.name === name) {
            if (obj[key]) {
                obj[key].name = name;
                return obj[key];
            }
            return obj;
        }
    }
    return null;
} //# sourceMappingURL=config.js.map
}),
"[project]/node_modules/@kubernetes/client-node/dist/watch.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Watch",
    ()=>Watch
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$http__$5b$external$5d$__$28$node$3a$http$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:http [external] (node:http, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$readline__$5b$external$5d$__$28$node$3a$readline$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:readline [external] (node:readline, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/lib/index.mjs [app-route] (ecmascript)");
;
;
;
class Watch {
    constructor(config){
        this.config = config;
    }
    // Watch the resource and call provided callback with parsed json object
    // upon event received over the watcher connection.
    //
    // "done" callback is called either when connection is closed or when there
    // is an error. In either case, watcher takes care of properly closing the
    // underlaying connection so that it doesn't leak any resources.
    async watch(path, queryParams, callback, done) {
        const cluster = this.config.getCurrentCluster();
        if (!cluster) {
            throw new Error('No currently active cluster');
        }
        const watchURL = new URL(cluster.server + path);
        watchURL.searchParams.set('watch', 'true');
        for (const [key, val] of Object.entries(queryParams || {})){
            if (val !== undefined) {
                watchURL.searchParams.set(key, val.toString());
            }
        }
        const requestInit = await this.config.applyToFetchOptions({});
        const controller = new AbortController();
        const timeoutSignal = AbortSignal.timeout(30000);
        requestInit.signal = AbortSignal.any([
            controller.signal,
            timeoutSignal
        ]);
        requestInit.signal = controller.signal;
        requestInit.method = 'GET';
        let doneCalled = false;
        const doneCallOnce = (err)=>{
            if (!doneCalled) {
                doneCalled = true;
                controller.abort();
                done(err);
            }
        };
        try {
            const response = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(watchURL, requestInit);
            if (requestInit.agent && typeof requestInit.agent === 'object') {
                for (const socket of Object.values(requestInit.agent.sockets).flat()){
                    socket === null || socket === void 0 ? void 0 : socket.setKeepAlive(true, 30000);
                }
            }
            if (response.status === 200) {
                const body = response.body;
                body.on('error', doneCallOnce);
                body.on('close', ()=>doneCallOnce(null));
                body.on('finish', ()=>doneCallOnce(null));
                const lines = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$readline__$5b$external$5d$__$28$node$3a$readline$2c$__cjs$29$__["createInterface"])(body);
                lines.on('error', doneCallOnce);
                lines.on('close', ()=>doneCallOnce(null));
                lines.on('finish', ()=>doneCallOnce(null));
                lines.on('line', (line)=>{
                    try {
                        const data = JSON.parse(line.toString());
                        callback(data.type, data.object, data);
                    } catch  {
                    // ignore parse errors
                    }
                });
            } else {
                const statusText = response.statusText || __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$http__$5b$external$5d$__$28$node$3a$http$2c$__cjs$29$__["STATUS_CODES"][response.status] || 'Internal Server Error';
                const error = new Error(statusText);
                error.statusCode = response.status;
                throw error;
            }
        } catch (err) {
            doneCallOnce(err);
        }
        return controller;
    }
}
Watch.SERVER_SIDE_CLOSE = {
    error: 'Connection closed on server'
}; //# sourceMappingURL=watch.js.map
}),
"[project]/node_modules/@kubernetes/client-node/dist/informer.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ADD",
    ()=>ADD,
    "CHANGE",
    ()=>CHANGE,
    "CONNECT",
    ()=>CONNECT,
    "DELETE",
    ()=>DELETE,
    "ERROR",
    ()=>ERROR,
    "UPDATE",
    ()=>UPDATE,
    "makeInformer",
    ()=>makeInformer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$cache$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/cache.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$watch$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/watch.js [app-route] (ecmascript)");
;
;
const ADD = 'add';
const UPDATE = 'update';
const CHANGE = 'change';
const DELETE = 'delete';
const CONNECT = 'connect';
const ERROR = 'error';
function makeInformer(kubeconfig, path, listPromiseFn, labelSelector) {
    const watch = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$watch$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Watch"](kubeconfig);
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$cache$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ListWatch"](path, watch, listPromiseFn, false, labelSelector);
} //# sourceMappingURL=informer.js.map
}),
"[project]/node_modules/@kubernetes/client-node/dist/serializer.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ObjectSerializer",
    ()=>ObjectSerializer,
    "defaultSerializer",
    ()=>defaultSerializer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$models$2f$ObjectSerializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/gen/models/ObjectSerializer.js [app-route] (ecmascript) <locals>");
;
const isKubernetesObject = (data)=>!!data && typeof data === 'object' && 'apiVersion' in data && 'kind' in data;
class KubernetesObject {
    serialize() {
        const instance = {};
        for (const attributeType of KubernetesObject.attributeTypeMap){
            const value = this[attributeType.baseName];
            if (value !== undefined) {
                instance[attributeType.name] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$models$2f$ObjectSerializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ObjectSerializer"].serialize(this[attributeType.baseName], attributeType.type, attributeType.format);
            }
        }
        // add all unknown properties as is.
        for (const [key, value] of Object.entries(this)){
            if (KubernetesObject.attributeTypeMap.find((t)=>t.name === key)) {
                continue;
            }
            instance[key] = value;
        }
        return instance;
    }
    static fromUnknown(data) {
        if (!isKubernetesObject(data)) {
            throw new Error(`Unable to deseriliaze non-Kubernetes object ${data}.`);
        }
        const instance = new KubernetesObject();
        for (const attributeType of KubernetesObject.attributeTypeMap){
            const value = data[attributeType.baseName];
            if (value !== undefined) {
                instance[attributeType.name] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$models$2f$ObjectSerializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ObjectSerializer"].deserialize(data[attributeType.baseName], attributeType.type, attributeType.format);
            }
        }
        // add all unknown properties as is.
        for (const [key, value] of Object.entries(data)){
            if (KubernetesObject.attributeTypeMap.find((t)=>t.name === key)) {
                continue;
            }
            instance[key] = value;
        }
        return instance;
    }
}
KubernetesObject.attributeTypeMap = [
    {
        name: 'apiVersion',
        baseName: 'apiVersion',
        type: 'string',
        format: ''
    },
    {
        name: 'kind',
        baseName: 'kind',
        type: 'string',
        format: ''
    },
    {
        name: 'metadata',
        baseName: 'metadata',
        type: 'V1ObjectMeta',
        format: ''
    }
];
const gvString = ({ group, version })=>[
        group,
        version
    ].join('/');
const gvkFromObject = (obj)=>{
    const [g, v] = obj.apiVersion.split('/');
    return {
        kind: obj.kind,
        group: v ? g : '',
        version: v ? v : g
    };
};
const defaultSerializer = {
    serialize: (data, type, format)=>{
        if (data instanceof KubernetesObject) {
            return data.serialize();
        }
        return KubernetesObject.fromUnknown(data).serialize();
    },
    deserialize: (data, type, format)=>{
        return KubernetesObject.fromUnknown(data);
    }
};
class ObjectSerializer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$models$2f$ObjectSerializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ObjectSerializer"] {
    /**
     * Adds a dedicated seriliazer for a Kubernetes resource.
     * Every resource is uniquly identified using its group, version and kind.
     * @param gvk
     * @param serializer
     */ static registerModel(gvk, serializer) {
        var _a;
        var _b;
        const gv = gvString(gvk);
        const kinds = (_a = (_b = this.modelRegistry)[gv]) !== null && _a !== void 0 ? _a : _b[gv] = {};
        if (kinds[gvk.kind]) {
            throw new Error(`Kind ${gvk.kind} of ${gv} is already defined`);
        }
        kinds[gvk.kind] = serializer;
    }
    /**
     * Removes all registered models from the registry.
     */ static clearModelRegistry() {
        this.modelRegistry = {};
    }
    static getSerializerForObject(obj) {
        var _a;
        if (!isKubernetesObject(obj)) {
            return undefined;
        }
        const gvk = gvkFromObject(obj);
        return (_a = ObjectSerializer.modelRegistry[gvString(gvk)]) === null || _a === void 0 ? void 0 : _a[gvk.kind];
    }
    static serialize(data, type, format = '') {
        const serializer = ObjectSerializer.getSerializerForObject(data);
        if (serializer) {
            return serializer.serialize(data, type, format);
        }
        if (data instanceof KubernetesObject) {
            return data.serialize();
        }
        const obj = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$models$2f$ObjectSerializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ObjectSerializer"].serialize(data, type, format);
        if (obj !== data) {
            return obj;
        }
        if (!isKubernetesObject(data)) {
            return obj;
        }
        const instance = {};
        for (const attributeType of KubernetesObject.attributeTypeMap){
            const value = data[attributeType.baseName];
            if (value !== undefined) {
                instance[attributeType.name] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$models$2f$ObjectSerializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ObjectSerializer"].serialize(data[attributeType.baseName], attributeType.type, attributeType.format);
            }
        }
        // add all unknown properties as is.
        for (const [key, value] of Object.entries(data)){
            if (KubernetesObject.attributeTypeMap.find((t)=>t.name === key)) {
                continue;
            }
            instance[key] = value;
        }
        return instance;
    }
    static deserialize(data, type, format = '') {
        const serializer = ObjectSerializer.getSerializerForObject(data);
        if (serializer) {
            return serializer.deserialize(data, type, format);
        }
        const obj = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$models$2f$ObjectSerializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__["ObjectSerializer"].deserialize(data, type, format);
        if (obj !== data) {
            // the serializer knows the type and already deserialized it.
            return obj;
        }
        if (!isKubernetesObject(data)) {
            return obj;
        }
        return KubernetesObject.fromUnknown(data);
    }
}
ObjectSerializer.modelRegistry = {}; //# sourceMappingURL=serializer.js.map
}),
"[project]/node_modules/@kubernetes/client-node/dist/cache.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ListWatch",
    ()=>ListWatch,
    "addOrUpdateObject",
    ()=>addOrUpdateObject,
    "cacheMapFromList",
    ()=>cacheMapFromList,
    "deleteItems",
    ()=>deleteItems,
    "deleteObject",
    ()=>deleteObject
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$informer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/informer.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/serializer.js [app-route] (ecmascript)");
;
;
class ListWatch {
    constructor(path, watch, listFn, autoStart = true, labelSelector, fieldSelector){
        this.objects = new Map();
        this.indexCache = {};
        this.callbackCache = {};
        this.stopped = false;
        this.path = path;
        this.watch = watch;
        this.listFn = listFn;
        this.labelSelector = labelSelector;
        this.fieldSelector = fieldSelector;
        this.callbackCache[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$informer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ADD"]] = [];
        this.callbackCache[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$informer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UPDATE"]] = [];
        this.callbackCache[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$informer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DELETE"]] = [];
        this.callbackCache[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$informer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ERROR"]] = [];
        this.callbackCache[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$informer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CONNECT"]] = [];
        this.resourceVersion = '';
        if (autoStart) {
            this.doneHandler(null);
        }
    }
    async start() {
        this.stopped = false;
        await this.doneHandler(null);
    }
    async stop() {
        this.stopped = true;
        this._stop();
    }
    on(verb, cb) {
        if (verb === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$informer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CHANGE"]) {
            this.on(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$informer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ADD"], cb);
            this.on(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$informer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UPDATE"], cb);
            this.on(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$informer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DELETE"], cb);
            return;
        }
        if (this.callbackCache[verb] === undefined) {
            throw new Error(`Unknown verb: ${verb}`);
        }
        this.callbackCache[verb].push(cb);
    }
    off(verb, cb) {
        if (verb === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$informer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CHANGE"]) {
            this.off('add', cb);
            this.off('update', cb);
            this.off('delete', cb);
            return;
        }
        if (this.callbackCache[verb] === undefined) {
            throw new Error(`Unknown verb: ${verb}`);
        }
        const indexToRemove = this.callbackCache[verb].findIndex((cachedCb)=>cachedCb === cb);
        if (indexToRemove === -1) {
            return;
        }
        this.callbackCache[verb].splice(indexToRemove, 1);
    }
    get(name, namespace) {
        const nsObjects = this.objects.get(namespace || '');
        if (nsObjects) {
            return nsObjects.get(name);
        }
        return undefined;
    }
    list(namespace) {
        if (!namespace) {
            const allObjects = [];
            for (const nsObjects of this.objects.values()){
                allObjects.push(...nsObjects.values());
            }
            return allObjects;
        }
        const namespaceObjects = this.objects.get(namespace || '');
        if (!namespaceObjects) {
            return [];
        }
        return Array.from(namespaceObjects.values());
    }
    latestResourceVersion() {
        return this.resourceVersion;
    }
    _stop() {
        if (this.request) {
            this.request.abort();
            this.request = undefined;
        }
    }
    async doneHandler(err) {
        this._stop();
        if (err && (err.statusCode === 410 || err.code === 410)) {
            this.resourceVersion = '';
        } else if (err) {
            this.callbackCache[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$informer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ERROR"]].forEach((elt)=>elt(err));
            return;
        }
        if (this.stopped) {
            // do not auto-restart
            return;
        }
        this.callbackCache[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$informer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CONNECT"]].forEach((elt)=>elt(undefined));
        if (!this.resourceVersion) {
            let list;
            try {
                const promise = this.listFn();
                list = await promise;
            } catch (err) {
                this.callbackCache[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$informer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ERROR"]].forEach((elt)=>elt(err));
                return;
            }
            this.objects = deleteItems(this.objects, list.items, this.callbackCache[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$informer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DELETE"]].slice());
            this.addOrUpdateItems(list.items);
            this.resourceVersion = list.metadata ? list.metadata.resourceVersion || '' : '';
        }
        const queryParams = {
            resourceVersion: this.resourceVersion
        };
        if (this.labelSelector !== undefined) {
            queryParams.labelSelector = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].serialize(this.labelSelector, 'string');
        }
        if (this.fieldSelector !== undefined) {
            queryParams.fieldSelector = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].serialize(this.fieldSelector, 'string');
        }
        this.request = await this.watch.watch(this.path, queryParams, this.watchHandler.bind(this), this.doneHandler.bind(this));
    }
    addOrUpdateItems(items) {
        if (items === undefined || items === null) {
            return;
        }
        items.forEach((obj)=>{
            addOrUpdateObject(this.objects, obj, this.callbackCache[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$informer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ADD"]].slice(), this.callbackCache[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$informer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UPDATE"]].slice());
        });
    }
    async watchHandler(phase, obj, watchObj) {
        switch(phase){
            case 'ERROR':
                if (obj.code === 410) {
                    this.resourceVersion = '';
                }
                // We don't restart here, because it should be handled by the watch exiting if necessary
                return;
            case 'ADDED':
            case 'MODIFIED':
                addOrUpdateObject(this.objects, obj, this.callbackCache[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$informer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ADD"]].slice(), this.callbackCache[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$informer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UPDATE"]].slice());
                break;
            case 'DELETED':
                deleteObject(this.objects, obj, this.callbackCache[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$informer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DELETE"]].slice());
                break;
            case 'BOOKMARK':
                break;
        }
        this.resourceVersion = obj.metadata ? obj.metadata.resourceVersion || '' : '';
    }
}
function cacheMapFromList(newObjects) {
    const objects = new Map();
    if (newObjects === undefined || newObjects === null) {
        return objects;
    }
    // build up the new list
    for (const obj of newObjects){
        let namespaceObjects = objects.get(obj.metadata.namespace || '');
        if (!namespaceObjects) {
            namespaceObjects = new Map();
            objects.set(obj.metadata.namespace || '', namespaceObjects);
        }
        const name = obj.metadata.name || '';
        namespaceObjects.set(name, obj);
    }
    return objects;
}
function deleteItems(oldObjects, newObjects, deleteCallback) {
    const newObjectsMap = cacheMapFromList(newObjects);
    for (const [namespace, oldNamespaceObjects] of oldObjects.entries()){
        const newNamespaceObjects = newObjectsMap.get(namespace);
        if (newNamespaceObjects) {
            for (const [name, oldObj] of oldNamespaceObjects.entries()){
                if (!newNamespaceObjects.has(name)) {
                    oldNamespaceObjects.delete(name);
                    if (deleteCallback) {
                        deleteCallback.forEach((fn)=>fn(oldObj));
                    }
                }
            }
        } else {
            oldObjects.delete(namespace);
            oldNamespaceObjects.forEach((obj)=>{
                if (deleteCallback) {
                    deleteCallback.forEach((fn)=>fn(obj));
                }
            });
        }
    }
    return oldObjects;
}
function addOrUpdateObject(objects, obj, addCallbacks, updateCallbacks) {
    let namespaceObjects = objects.get(obj.metadata.namespace || '');
    if (!namespaceObjects) {
        namespaceObjects = new Map();
        objects.set(obj.metadata.namespace || '', namespaceObjects);
    }
    const name = obj.metadata.name || '';
    const found = namespaceObjects.get(name);
    if (!found) {
        namespaceObjects.set(name, obj);
        if (addCallbacks) {
            addCallbacks.forEach((elt)=>elt(obj));
        }
    } else {
        if (!isSameVersion(found, obj)) {
            namespaceObjects.set(name, obj);
            if (updateCallbacks) {
                updateCallbacks.forEach((elt)=>elt(obj));
            }
        }
    }
}
function isSameVersion(o1, o2) {
    return o1.metadata.resourceVersion !== undefined && o1.metadata.resourceVersion !== null && o1.metadata.resourceVersion === o2.metadata.resourceVersion;
}
function deleteObject(objects, obj, deleteCallbacks) {
    const namespace = obj.metadata.namespace || '';
    const name = obj.metadata.name || '';
    const namespaceObjects = objects.get(namespace);
    if (!namespaceObjects) {
        return;
    }
    const deleted = namespaceObjects.delete(name);
    if (deleted) {
        if (deleteCallbacks) {
            deleteCallbacks.forEach((elt)=>elt(obj));
        }
        if (namespaceObjects.size === 0) {
            objects.delete(namespace);
        }
    }
} //# sourceMappingURL=cache.js.map
}),
"[project]/node_modules/@kubernetes/client-node/dist/api.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/gen/index.js [app-route] (ecmascript) <locals>"); //# sourceMappingURL=api.js.map
;
}),
"[project]/node_modules/@kubernetes/client-node/dist/terminal-size-queue.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "TerminalSizeQueue",
    ()=>TerminalSizeQueue,
    "isResizable",
    ()=>isResizable
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:stream [external] (node:stream, cjs)");
;
class TerminalSizeQueue extends __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$stream__$5b$external$5d$__$28$node$3a$stream$2c$__cjs$29$__["Readable"] {
    constructor(opts = {}){
        super({
            ...opts,
            read () {}
        });
    }
    handleResizes(writeStream) {
        // Set initial size
        this.resize(getTerminalSize(writeStream));
        // Handle future size updates
        writeStream.on('resize', ()=>this.resize(getTerminalSize(writeStream)));
    }
    resize(size) {
        this.push(JSON.stringify(size));
    }
}
function isResizable(stream) {
    if (stream == null) {
        return false;
    }
    const hasRows = 'rows' in stream;
    const hasColumns = 'columns' in stream;
    const hasOn = typeof stream.on === 'function';
    return hasRows && hasColumns && hasOn;
}
function getTerminalSize(writeStream) {
    return {
        height: writeStream.rows,
        width: writeStream.columns
    };
} //# sourceMappingURL=terminal-size-queue.js.map
}),
"[project]/node_modules/@kubernetes/client-node/dist/web-socket-handler.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "WebSocketHandler",
    ()=>WebSocketHandler
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$isomorphic$2d$ws$2f$node$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/isomorphic-ws/node.js [app-route] (ecmascript)");
;
const protocols = [
    'v5.channel.k8s.io',
    'v4.channel.k8s.io',
    'v3.channel.k8s.io',
    'v2.channel.k8s.io',
    'channel.k8s.io'
];
class WebSocketHandler {
    static supportsClose(protocol) {
        return protocol === 'v5.channel.k8s.io';
    }
    static closeStream(streamNum, streams) {
        switch(streamNum){
            case WebSocketHandler.StdinStream:
                streams.stdin.pause();
                break;
            case WebSocketHandler.StdoutStream:
                streams.stdout.end();
                break;
            case WebSocketHandler.StderrStream:
                streams.stderr.end();
                break;
        }
    }
    static handleStandardStreams(streamNum, buff, stdout, stderr) {
        if (buff.length < 1) {
            return null;
        }
        if (stdout && streamNum === WebSocketHandler.StdoutStream) {
            stdout.write(buff);
        } else if (stderr && streamNum === WebSocketHandler.StderrStream) {
            stderr.write(buff);
        } else if (streamNum === WebSocketHandler.StatusStream) {
            // stream closing.
            // Hacky, change tests to use the stream interface
            if (stdout && stdout !== process.stdout) {
                stdout.end();
            }
            if (stderr && stderr !== process.stderr) {
                stderr.end();
            }
            return JSON.parse(buff.toString('utf8'));
        } else {
            throw new Error('Unknown stream: ' + streamNum);
        }
        return null;
    }
    static handleStandardInput(ws, stdin, streamNum = 0) {
        stdin.on('data', (data)=>{
            ws.send(copyChunkForWebSocket(streamNum, data, stdin.readableEncoding));
        });
        stdin.on('end', ()=>{
            if (WebSocketHandler.supportsClose(ws.protocol)) {
                const buff = Buffer.alloc(2);
                buff.writeUint8(this.CloseStream, 0);
                buff.writeUint8(this.StdinStream, 1);
                ws.send(buff);
                return;
            }
            ws.close();
        });
        // Keep the stream open
        return true;
    }
    static async processData(data, ws, createWS, streamNum = 0, retryCount = 3, encoding) {
        const buff = copyChunkForWebSocket(streamNum, data, encoding);
        let i = 0;
        for(; i < retryCount; ++i){
            if (ws !== null && ws.readyState === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$isomorphic$2d$ws$2f$node$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].OPEN) {
                ws.send(buff);
                break;
            } else {
                ws = await createWS();
            }
        }
        // This throw doesn't go anywhere.
        // TODO: Figure out the right way to return an error.
        if (i >= retryCount) {
            throw new Error("can't send data to ws");
        }
        return ws;
    }
    static restartableHandleStandardInput(createWS, stdin, streamNum = 0, retryCount = 3, // kind of hacky, but otherwise we can't wait for the writes to flush before testing.
    addFlushForTesting = false) {
        if (retryCount < 0) {
            throw new Error("retryCount can't be lower than 0.");
        }
        let queue = Promise.resolve();
        let ws = null;
        stdin.on('data', (data)=>{
            queue = queue.then(async ()=>{
                ws = await WebSocketHandler.processData(data, ws, createWS, streamNum, retryCount, stdin.readableEncoding);
            });
        });
        if (addFlushForTesting) {
            stdin.on('flush', async ()=>{
                await queue;
            });
        }
        stdin.on('end', ()=>{
            if (ws !== null) {
                ws.close();
            }
        });
        return ()=>ws;
    }
    // factory is really just for test injection
    constructor(kc, socketFactoryFn, streamsInterface = {
        stdin: process.stdin,
        stdout: process.stdout,
        stderr: process.stderr
    }){
        this.config = kc;
        this.socketFactory = socketFactoryFn;
        this.streams = streamsInterface;
    }
    /**
     * Connect to a web socket endpoint.
     * @param path The HTTP Path to connect to on the server.
     * @param textHandler Callback for text over the web socket.
     *      Returns true if the connection should be kept alive, false to disconnect.
     * @param binaryHandler Callback for binary data over the web socket.
     *      Returns true if the connection should be kept alive, false to disconnect.
     */ async connect(path, textHandler, binaryHandler) {
        const cluster = this.config.getCurrentCluster();
        if (!cluster) {
            throw new Error('No cluster is defined.');
        }
        const server = cluster.server;
        const ssl = server.startsWith('https://');
        const target = ssl ? server.substr(8) : server.substr(7);
        const proto = ssl ? 'wss' : 'ws';
        const uri = `${proto}://${target}${path}`;
        const opts = {};
        await this.config.applyToHTTPSOptions(opts);
        return await new Promise((resolve, reject)=>{
            const client = this.socketFactory ? this.socketFactory(uri, protocols, opts) : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$isomorphic$2d$ws$2f$node$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"](uri, protocols, opts);
            let resolved = false;
            client.onopen = ()=>{
                resolved = true;
                resolve(client);
            };
            client.onerror = (err)=>{
                if (!resolved) {
                    reject(err);
                }
            };
            client.onmessage = ({ data })=>{
                // TODO: support ArrayBuffer and Buffer[] data types?
                if (typeof data === 'string') {
                    if (data.charCodeAt(0) === WebSocketHandler.CloseStream) {
                        WebSocketHandler.closeStream(data.charCodeAt(1), this.streams);
                    }
                    if (textHandler && !textHandler(data)) {
                        client.close();
                    }
                } else if (data instanceof Buffer) {
                    const streamNum = data.readUint8(0);
                    if (streamNum === WebSocketHandler.CloseStream) {
                        WebSocketHandler.closeStream(data.readInt8(1), this.streams);
                    }
                    if (binaryHandler && !binaryHandler(streamNum, data.slice(1))) {
                        client.close();
                    }
                }
            };
        });
    }
}
WebSocketHandler.StdinStream = 0;
WebSocketHandler.StdoutStream = 1;
WebSocketHandler.StderrStream = 2;
WebSocketHandler.StatusStream = 3;
WebSocketHandler.ResizeStream = 4;
WebSocketHandler.CloseStream = 255;
function copyChunkForWebSocket(streamNum, chunk, encoding) {
    let buff;
    if (chunk instanceof Buffer) {
        buff = Buffer.alloc(chunk.length + 1);
        chunk.copy(buff, 1);
    } else {
        encoding !== null && encoding !== void 0 ? encoding : encoding = 'utf-8';
        const size = Buffer.byteLength(chunk, encoding);
        buff = Buffer.alloc(size + 1);
        buff.write(chunk, 1, size, encoding);
    }
    buff.writeInt8(streamNum, 0);
    return buff;
} //# sourceMappingURL=web-socket-handler.js.map
}),
"[project]/node_modules/@kubernetes/client-node/dist/attach.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Attach",
    ()=>Attach
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$querystring__$5b$external$5d$__$28$node$3a$querystring$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:querystring [external] (node:querystring, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$terminal$2d$size$2d$queue$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/terminal-size-queue.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$web$2d$socket$2d$handler$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/web-socket-handler.js [app-route] (ecmascript)");
;
;
;
class Attach {
    constructor(config, websocketInterface){
        this.handler = websocketInterface || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$web$2d$socket$2d$handler$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["WebSocketHandler"](config);
    }
    async attach(namespace, podName, containerName, stdout, stderr, stdin, tty) {
        const query = {
            container: containerName,
            stderr: stderr != null,
            stdin: stdin != null,
            stdout: stdout != null,
            tty
        };
        const queryStr = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$querystring__$5b$external$5d$__$28$node$3a$querystring$2c$__cjs$29$__["default"].stringify(query);
        const path = `/api/v1/namespaces/${namespace}/pods/${podName}/attach?${queryStr}`;
        const conn = await this.handler.connect(path, null, (streamNum, buff)=>{
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$web$2d$socket$2d$handler$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["WebSocketHandler"].handleStandardStreams(streamNum, buff, stdout, stderr);
            return true;
        });
        if (stdin != null) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$web$2d$socket$2d$handler$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["WebSocketHandler"].handleStandardInput(conn, stdin, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$web$2d$socket$2d$handler$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["WebSocketHandler"].StdinStream);
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$terminal$2d$size$2d$queue$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isResizable"])(stdout)) {
            this.terminalSizeQueue = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$terminal$2d$size$2d$queue$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TerminalSizeQueue"]();
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$web$2d$socket$2d$handler$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["WebSocketHandler"].handleStandardInput(conn, this.terminalSizeQueue, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$web$2d$socket$2d$handler$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["WebSocketHandler"].ResizeStream);
            this.terminalSizeQueue.handleResizes(stdout);
        }
        return conn;
    }
} //# sourceMappingURL=attach.js.map
}),
"[project]/node_modules/@kubernetes/client-node/dist/exec.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Exec",
    ()=>Exec
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$querystring__$5b$external$5d$__$28$node$3a$querystring$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:querystring [external] (node:querystring, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$terminal$2d$size$2d$queue$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/terminal-size-queue.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$web$2d$socket$2d$handler$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/web-socket-handler.js [app-route] (ecmascript)");
;
;
;
class Exec {
    constructor(config, wsInterface){
        this.handler = wsInterface || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$web$2d$socket$2d$handler$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["WebSocketHandler"](config);
    }
    /**
     * @param {string}  namespace - The namespace of the pod to exec the command inside.
     * @param {string} podName - The name of the pod to exec the command inside.
     * @param {string} containerName - The name of the container in the pod to exec the command inside.
     * @param {(string|string[])} command - The command or command and arguments to execute.
     * @param {stream.Writable} stdout - The stream to write stdout data from the command.
     * @param {stream.Writable} stderr - The stream to write stderr data from the command.
     * @param {stream.Readable} stdin - The stream to write stdin data into the command.
     * @param {boolean} tty - Should the command execute in a TTY enabled session.
     * @param {(V1Status) => void} statusCallback -
     *       A callback to received the status (e.g. exit code) from the command, optional.
     * @return {Promise<WebSocket>} A promise that will return the web socket created for this command.
     */ async exec(namespace, podName, containerName, command, stdout, stderr, stdin, tty, statusCallback) {
        const query = {
            stdout: stdout != null,
            stderr: stderr != null,
            stdin: stdin != null,
            tty,
            command,
            container: containerName
        };
        const queryStr = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$querystring__$5b$external$5d$__$28$node$3a$querystring$2c$__cjs$29$__["default"].stringify(query);
        const path = `/api/v1/namespaces/${namespace}/pods/${podName}/exec?${queryStr}`;
        const conn = await this.handler.connect(path, null, (streamNum, buff)=>{
            const status = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$web$2d$socket$2d$handler$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["WebSocketHandler"].handleStandardStreams(streamNum, buff, stdout, stderr);
            if (status != null) {
                if (statusCallback) {
                    statusCallback(status);
                }
                return false;
            }
            return true;
        });
        if (stdin != null) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$web$2d$socket$2d$handler$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["WebSocketHandler"].handleStandardInput(conn, stdin, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$web$2d$socket$2d$handler$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["WebSocketHandler"].StdinStream);
        }
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$terminal$2d$size$2d$queue$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["isResizable"])(stdout)) {
            this.terminalSizeQueue = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$terminal$2d$size$2d$queue$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TerminalSizeQueue"]();
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$web$2d$socket$2d$handler$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["WebSocketHandler"].handleStandardInput(conn, this.terminalSizeQueue, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$web$2d$socket$2d$handler$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["WebSocketHandler"].ResizeStream);
            this.terminalSizeQueue.handleResizes(stdout);
        }
        return conn;
    }
} //# sourceMappingURL=exec.js.map
}),
"[project]/node_modules/@kubernetes/client-node/dist/portforward.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PortForward",
    ()=>PortForward
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$querystring__$5b$external$5d$__$28$node$3a$querystring$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/node:querystring [external] (node:querystring, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$web$2d$socket$2d$handler$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/web-socket-handler.js [app-route] (ecmascript)");
;
;
class PortForward {
    // handler is a parameter really only for injecting for testing.
    constructor(config, disconnectOnErr, handler){
        this.handler = handler || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$web$2d$socket$2d$handler$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["WebSocketHandler"](config);
        this.disconnectOnErr = disconnectOnErr === undefined ? true : disconnectOnErr;
    }
    // TODO: support multiple ports for real...
    async portForward(namespace, podName, targetPorts, output, err, input, retryCount = 0) {
        if (targetPorts.length === 0) {
            throw new Error('You must provide at least one port to forward to.');
        }
        if (targetPorts.length > 1) {
            throw new Error('Only one port is currently supported for port-forward');
        }
        const query = {
            ports: targetPorts[0]
        };
        const queryStr = __TURBOPACK__imported__module__$5b$externals$5d2f$node$3a$querystring__$5b$external$5d$__$28$node$3a$querystring$2c$__cjs$29$__["default"].stringify(query);
        const needsToReadPortNumber = [];
        targetPorts.forEach((value, index)=>{
            needsToReadPortNumber[index * 2] = true;
            needsToReadPortNumber[index * 2 + 1] = true;
        });
        const path = `/api/v1/namespaces/${namespace}/pods/${podName}/portforward?${queryStr}`;
        const createWebSocket = ()=>{
            return this.handler.connect(path, null, (streamNum, buff)=>{
                if (streamNum >= targetPorts.length * 2) {
                    return !this.disconnectOnErr;
                }
                // First two bytes of each stream are the port number
                if (needsToReadPortNumber[streamNum]) {
                    buff = buff.slice(2);
                    needsToReadPortNumber[streamNum] = false;
                }
                if (streamNum % 2 === 1) {
                    if (err) {
                        err.write(buff);
                    }
                } else {
                    output.write(buff);
                }
                return true;
            });
        };
        if (retryCount < 1) {
            const ws = await createWebSocket();
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$web$2d$socket$2d$handler$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["WebSocketHandler"].handleStandardInput(ws, input, 0);
            return ws;
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$web$2d$socket$2d$handler$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["WebSocketHandler"].restartableHandleStandardInput(createWebSocket, input, 0, retryCount);
    }
} //# sourceMappingURL=portforward.js.map
}),
"[project]/node_modules/@kubernetes/client-node/dist/types.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "V1MicroTime",
    ()=>V1MicroTime
]);
class V1MicroTime extends Date {
    toISOString() {
        return super.toISOString().slice(0, -1) + '000Z';
    }
} //# sourceMappingURL=types.js.map
}),
"[project]/node_modules/@kubernetes/client-node/dist/util.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ResourceStatus",
    ()=>ResourceStatus,
    "add",
    ()=>add,
    "containerTotalForResource",
    ()=>containerTotalForResource,
    "findSuffix",
    ()=>findSuffix,
    "getSerializationType",
    ()=>getSerializationType,
    "normalizeResponseHeaders",
    ()=>normalizeResponseHeaders,
    "podsForNode",
    ()=>podsForNode,
    "quantityToScalar",
    ()=>quantityToScalar,
    "totalCPU",
    ()=>totalCPU,
    "totalCPUForContainer",
    ()=>totalCPUForContainer,
    "totalForResource",
    ()=>totalForResource,
    "totalMemory",
    ()=>totalMemory,
    "totalMemoryForContainer",
    ()=>totalMemoryForContainer
]);
async function podsForNode(api, nodeName) {
    const allPods = await api.listPodForAllNamespaces();
    if (!allPods.items) {
        return [];
    }
    return allPods.items.filter((pod)=>pod.spec.nodeName === nodeName);
}
function findSuffix(quantity) {
    let ix = quantity.length - 1;
    while(ix >= 0 && !/[.0-9]/.test(quantity.charAt(ix))){
        ix--;
    }
    return ix === -1 ? '' : quantity.substring(ix + 1);
}
function quantityToScalar(quantity) {
    if (!quantity) {
        return 0;
    }
    const suffix = findSuffix(quantity);
    if (suffix === '') {
        const num = Number(quantity).valueOf();
        if (isNaN(num)) {
            throw new Error('Unknown quantity ' + quantity);
        }
        return num;
    }
    switch(suffix){
        case 'n':
            return Number(quantity.substr(0, quantity.length - 1)).valueOf() / 1000000000;
        case 'u':
            return Number(quantity.substr(0, quantity.length - 1)).valueOf() / 1000000;
        case 'm':
            return Number(quantity.substr(0, quantity.length - 1)).valueOf() / 1000.0;
        case 'k':
            return BigInt(quantity.substr(0, quantity.length - 1)) * BigInt(1000);
        case 'M':
            return BigInt(quantity.substr(0, quantity.length - 1)) * BigInt(1000 * 1000);
        case 'G':
            return BigInt(quantity.substr(0, quantity.length - 1)) * BigInt(1000 * 1000 * 1000);
        case 'T':
            return BigInt(quantity.substr(0, quantity.length - 1)) * BigInt(1000 * 1000 * 1000) * BigInt(1000);
        case 'P':
            return BigInt(quantity.substr(0, quantity.length - 1)) * BigInt(1000 * 1000 * 1000) * BigInt(1000 * 1000);
        case 'E':
            return BigInt(quantity.substr(0, quantity.length - 1)) * BigInt(1000 * 1000 * 1000) * BigInt(1000 * 1000 * 1000);
        case 'Ki':
            return BigInt(quantity.substr(0, quantity.length - 2)) * BigInt(1024);
        case 'Mi':
            return BigInt(quantity.substr(0, quantity.length - 2)) * BigInt(1024 * 1024);
        case 'Gi':
            return BigInt(quantity.substr(0, quantity.length - 2)) * BigInt(1024 * 1024 * 1024);
        case 'Ti':
            return BigInt(quantity.substr(0, quantity.length - 2)) * BigInt(1024 * 1024 * 1024) * BigInt(1024);
        case 'Pi':
            return BigInt(quantity.substr(0, quantity.length - 2)) * BigInt(1024 * 1024 * 1024) * BigInt(1024 * 1024);
        case 'Ei':
            return BigInt(quantity.substr(0, quantity.length - 2)) * BigInt(1024 * 1024 * 1024) * BigInt(1024 * 1024 * 1024);
        default:
            throw new Error(`Unknown suffix: ${suffix}`);
    }
}
class ResourceStatus {
    constructor(request, limit, resourceType){
        this.request = request;
        this.limit = limit;
        this.resourceType = resourceType;
    }
}
function totalCPUForContainer(container) {
    return containerTotalForResource(container, 'cpu');
}
function totalMemoryForContainer(container) {
    return containerTotalForResource(container, 'memory');
}
function totalCPU(pod) {
    return totalForResource(pod, 'cpu');
}
function totalMemory(pod) {
    return totalForResource(pod, 'memory');
}
function add(n1, n2) {
    if (typeof n1 === 'number' && typeof n2 === 'number') {
        return n1 + n2;
    }
    if (typeof n1 === 'number') {
        return BigInt(Math.round(n1)) + BigInt(n2);
    } else if (typeof n2 === 'number') {
        return BigInt(n1) + BigInt(Math.round(n2));
    }
    return BigInt(n1) + BigInt(n2);
}
function containerTotalForResource(container, resource) {
    let reqTotal = 0;
    let limitTotal = 0;
    if (container.resources) {
        if (container.resources.requests) {
            reqTotal = add(reqTotal, quantityToScalar(container.resources.requests[resource]));
        }
        if (container.resources.limits) {
            limitTotal = add(limitTotal, quantityToScalar(container.resources.limits[resource]));
        }
    }
    return new ResourceStatus(reqTotal, limitTotal, resource);
}
function totalForResource(pod, resource) {
    let reqTotal = 0;
    let limitTotal = 0;
    pod.spec.containers.forEach((container)=>{
        const containerTotal = containerTotalForResource(container, resource);
        reqTotal = add(reqTotal, containerTotal.request);
        limitTotal = add(limitTotal, containerTotal.limit);
    });
    return new ResourceStatus(reqTotal, limitTotal, resource);
}
function normalizeResponseHeaders(response) {
    const normalizedHeaders = {};
    for (const [key, value] of response.headers.entries()){
        normalizedHeaders[key] = value;
    }
    return normalizedHeaders;
}
function getSerializationType(apiVersion, kind) {
    if (apiVersion === undefined || kind === undefined) {
        return 'KubernetesObject';
    }
    // Types are defined in src/gen/api/models with the format "<Version><Kind>".
    // Version and Kind are in PascalCase.
    const gv = groupVersion(apiVersion);
    const version = gv.version.charAt(0).toUpperCase() + gv.version.slice(1);
    return `${version}${kind}`;
}
function groupVersion(apiVersion) {
    const v = apiVersion.split('/');
    return v.length === 1 ? {
        group: 'core',
        version: apiVersion
    } : {
        group: v[0],
        version: v[1]
    };
} //# sourceMappingURL=util.js.map
}),
"[project]/node_modules/@kubernetes/client-node/dist/yaml.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "dumpYaml",
    ()=>dumpYaml,
    "loadAllYaml",
    ()=>loadAllYaml,
    "loadYaml",
    ()=>loadYaml
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$js$2d$yaml$2f$dist$2f$js$2d$yaml$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/js-yaml/dist/js-yaml.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/util.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/serializer.js [app-route] (ecmascript)");
;
;
;
function loadYaml(data, opts) {
    const yml = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$js$2d$yaml$2f$dist$2f$js$2d$yaml$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].load(data, opts);
    if (!yml) {
        throw new Error('Failed to load YAML');
    }
    const type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getSerializationType"])(yml.apiVersion, yml.kind);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].deserialize(yml, type);
}
function loadAllYaml(data, opts) {
    const ymls = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$js$2d$yaml$2f$dist$2f$js$2d$yaml$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].loadAll(data, undefined, opts);
    return ymls.map((yml)=>{
        const obj = yml;
        const type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getSerializationType"])(obj.apiVersion, obj.kind);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].deserialize(yml, type);
    });
}
function dumpYaml(object, opts) {
    const kubeObject = object;
    const type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getSerializationType"])(kubeObject.apiVersion, kubeObject.kind);
    const serialized = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].serialize(kubeObject, type);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$js$2d$yaml$2f$dist$2f$js$2d$yaml$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].dump(serialized, opts);
} //# sourceMappingURL=yaml.js.map
}),
"[project]/node_modules/@kubernetes/client-node/dist/log.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AddOptionsToSearchParams",
    ()=>AddOptionsToSearchParams,
    "Log",
    ()=>Log
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/lib/index.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$api$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/api.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$apis$2f$exception$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/gen/apis/exception.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/util.js [app-route] (ecmascript)");
;
;
;
function AddOptionsToSearchParams(options, searchParams) {
    var _a, _b, _c, _d, _e, _f;
    if (!options) {
        return;
    }
    searchParams.append('follow', ((_a = options === null || options === void 0 ? void 0 : options.follow) === null || _a === void 0 ? void 0 : _a.toString()) || 'false');
    if (options === null || options === void 0 ? void 0 : options.limitBytes) {
        searchParams.set('limitBytes', options.limitBytes.toString());
    }
    searchParams.set('pretty', ((_b = options === null || options === void 0 ? void 0 : options.follow) === null || _b === void 0 ? void 0 : _b.toString()) || 'false');
    searchParams.set('previous', ((_c = options === null || options === void 0 ? void 0 : options.previous) === null || _c === void 0 ? void 0 : _c.toString()) || 'false');
    if (options === null || options === void 0 ? void 0 : options.sinceSeconds) {
        searchParams.set('sinceSeconds', ((_d = options === null || options === void 0 ? void 0 : options.sinceSeconds) === null || _d === void 0 ? void 0 : _d.toString()) || 'false');
    }
    if (options === null || options === void 0 ? void 0 : options.sinceTime) {
        if (options === null || options === void 0 ? void 0 : options.sinceSeconds) {
            throw new Error('at most one of sinceTime or sinceSeconds may be specified');
        }
        searchParams.set('sinceTime', options === null || options === void 0 ? void 0 : options.sinceTime);
    }
    if (options === null || options === void 0 ? void 0 : options.tailLines) {
        searchParams.set('tailLines', ((_e = options === null || options === void 0 ? void 0 : options.tailLines) === null || _e === void 0 ? void 0 : _e.toString()) || 'false');
    }
    searchParams.set('timestamps', ((_f = options === null || options === void 0 ? void 0 : options.timestamps) === null || _f === void 0 ? void 0 : _f.toString()) || 'false');
    return searchParams;
}
class Log {
    constructor(config){
        this.config = config;
    }
    async log(namespace, podName, containerName, stream, doneOrOptions, options) {
        if (typeof doneOrOptions !== 'function') {
            options = doneOrOptions;
        }
        const path = `/api/v1/namespaces/${namespace}/pods/${podName}/log`;
        const cluster = this.config.getCurrentCluster();
        if (!cluster) {
            throw new Error('No currently active cluster');
        }
        const requestURL = new URL(cluster.server + path);
        const searchParams = requestURL.searchParams;
        searchParams.set('container', containerName);
        AddOptionsToSearchParams(options, searchParams);
        const requestInit = await this.config.applyToFetchOptions({});
        const controller = new AbortController();
        requestInit.signal = controller.signal;
        requestInit.method = 'GET';
        try {
            const response = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(requestURL.toString(), requestInit);
            const status = response.status;
            if (status === 200) {
                // TODO: the follow search param still has the stream close prematurely based on my testing
                response.body.pipe(stream);
            } else if (status === 500) {
                const v1status = await response.json();
                const v1code = v1status.code;
                const v1message = v1status.message;
                if (v1code !== undefined && v1message !== undefined) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$apis$2f$exception$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ApiException"](v1code, v1message, v1status, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["normalizeResponseHeaders"])(response));
                } else {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$apis$2f$exception$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ApiException"](status, 'Error occurred in log request', undefined, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["normalizeResponseHeaders"])(response));
                }
            } else {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$apis$2f$exception$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ApiException"](status, 'Error occurred in log request', undefined, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["normalizeResponseHeaders"])(response));
            }
        } catch (err) {
            if (err instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$apis$2f$exception$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ApiException"]) {
                throw err;
            }
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$apis$2f$exception$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ApiException"](500, 'Error occurred in log request', undefined, {});
        }
        return controller;
    }
} //# sourceMappingURL=log.js.map
}),
"[project]/node_modules/@kubernetes/client-node/dist/top.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ContainerStatus",
    ()=>ContainerStatus,
    "CurrentResourceUsage",
    ()=>CurrentResourceUsage,
    "NodeStatus",
    ()=>NodeStatus,
    "PodStatus",
    ()=>PodStatus,
    "ResourceUsage",
    ()=>ResourceUsage,
    "topNodes",
    ()=>topNodes,
    "topPods",
    ()=>topPods
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/util.js [app-route] (ecmascript)");
;
class ResourceUsage {
    constructor(Capacity, RequestTotal, LimitTotal){
        this.Capacity = Capacity;
        this.RequestTotal = RequestTotal;
        this.LimitTotal = LimitTotal;
    }
}
class CurrentResourceUsage {
    constructor(CurrentUsage, RequestTotal, LimitTotal){
        this.CurrentUsage = CurrentUsage;
        this.RequestTotal = RequestTotal;
        this.LimitTotal = LimitTotal;
    }
}
class NodeStatus {
    constructor(Node, CPU, Memory){
        this.Node = Node;
        this.CPU = CPU;
        this.Memory = Memory;
    }
}
class ContainerStatus {
    constructor(Container, CPUUsage, MemoryUsage){
        this.Container = Container;
        this.CPUUsage = CPUUsage;
        this.MemoryUsage = MemoryUsage;
    }
}
class PodStatus {
    constructor(Pod, CPU, Memory, Containers){
        this.Pod = Pod;
        this.CPU = CPU;
        this.Memory = Memory;
        this.Containers = Containers;
    }
}
async function topNodes(api) {
    // TODO: Support metrics APIs in the client and this library
    const nodes = await api.listNode();
    const result = [];
    for (const node of nodes.items){
        const availableCPU = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["quantityToScalar"])(node.status.allocatable.cpu);
        const availableMem = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["quantityToScalar"])(node.status.allocatable.memory);
        let totalPodCPU = 0;
        let totalPodCPULimit = 0;
        let totalPodMem = 0;
        let totalPodMemLimit = 0;
        let pods = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["podsForNode"])(api, node.metadata.name);
        pods = pods.filter((pod)=>pod.status.phase === 'Running');
        pods.forEach((pod)=>{
            const cpuTotal = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["totalCPU"])(pod);
            totalPodCPU = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["add"])(totalPodCPU, cpuTotal.request);
            totalPodCPULimit = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["add"])(totalPodCPULimit, cpuTotal.limit);
            const memTotal = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["totalMemory"])(pod);
            totalPodMem = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["add"])(totalPodMem, memTotal.request);
            totalPodMemLimit = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["add"])(totalPodMemLimit, memTotal.limit);
        });
        const cpuUsage = new ResourceUsage(availableCPU, totalPodCPU, totalPodCPULimit);
        const memUsage = new ResourceUsage(availableMem, totalPodMem, totalPodMemLimit);
        result.push(new NodeStatus(node, cpuUsage, memUsage));
    }
    return result;
}
async function topPods(api, metrics, namespace) {
    // Figure out which pod list endpoint to call
    const getPodList = async ()=>{
        if (namespace) {
            return await api.listNamespacedPod({
                namespace
            });
        }
        return await api.listPodForAllNamespaces();
    };
    const [podMetrics, podList] = await Promise.all([
        metrics.getPodMetrics(namespace),
        getPodList()
    ]);
    // Create a map of pod names to their metric usage
    // to make it easier to look up when we need it later
    const podMetricsMap = podMetrics.items.reduce((accum, next)=>{
        accum.set(next.metadata.name, next);
        return accum;
    }, new Map());
    const result = [];
    for (const pod of podList.items){
        const podMetric = podMetricsMap.get(pod.metadata.name);
        const containerStatuses = [];
        let currentPodCPU = 0;
        let currentPodMem = 0;
        let podRequestsCPU = 0;
        let podLimitsCPU = 0;
        let podRequestsMem = 0;
        let podLimitsMem = 0;
        pod.spec.containers.forEach((container)=>{
            // get the the container CPU/Memory container.resources.requests/limits
            const containerCpuTotal = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["totalCPUForContainer"])(container);
            const containerMemTotal = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["totalMemoryForContainer"])(container);
            // sum each container's CPU/Memory container.resources.requests/limits
            // to get the pod's overall requests/limits
            podRequestsCPU = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["add"])(podRequestsCPU, containerCpuTotal.request);
            podLimitsCPU = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["add"])(podLimitsCPU, containerCpuTotal.limit);
            podRequestsMem = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["add"])(podLimitsMem, containerMemTotal.request);
            podLimitsMem = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["add"])(podLimitsMem, containerMemTotal.limit);
            // Find the container metrics by container.name
            // if both the pod and container metrics exist
            const containerMetrics = podMetric !== undefined ? podMetric.containers.find((c)=>c.name === container.name) : undefined;
            // Store the current usage of each container
            // Sum each container to get the overall pod usage
            if (containerMetrics !== undefined) {
                const currentContainerCPUUsage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["quantityToScalar"])(containerMetrics.usage.cpu);
                const currentContainerMemUsage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["quantityToScalar"])(containerMetrics.usage.memory);
                currentPodCPU = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["add"])(currentPodCPU, currentContainerCPUUsage);
                currentPodMem = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["add"])(currentPodMem, currentContainerMemUsage);
                const containerCpuUsage = new CurrentResourceUsage(currentContainerCPUUsage, containerCpuTotal.request, containerCpuTotal.limit);
                const containerMemUsage = new CurrentResourceUsage(currentContainerMemUsage, containerMemTotal.request, containerMemTotal.limit);
                containerStatuses.push(new ContainerStatus(containerMetrics.name, containerCpuUsage, containerMemUsage));
            }
        });
        const podCpuUsage = new CurrentResourceUsage(currentPodCPU, podRequestsCPU, podLimitsCPU);
        const podMemUsage = new CurrentResourceUsage(currentPodMem, podRequestsMem, podLimitsMem);
        result.push(new PodStatus(pod, podCpuUsage, podMemUsage, containerStatuses));
    }
    return result;
} //# sourceMappingURL=top.js.map
}),
"[project]/node_modules/@kubernetes/client-node/dist/cp.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Cp",
    ()=>Cp
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stream$2d$buffers$2f$lib$2f$streambuffer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stream-buffers/lib/streambuffer.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tar$2d$fs$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/tar-fs/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$exec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/exec.js [app-route] (ecmascript)");
;
;
;
class Cp {
    constructor(config, execInstance){
        this.execInstance = execInstance || new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$exec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Exec"](config);
    }
    /**
     * @param {string} namespace - The namespace of the pod to exec the command inside.
     * @param {string} podName - The name of the pod to exec the command inside.
     * @param {string} containerName - The name of the container in the pod to exec the command inside.
     * @param {string} srcPath - The source path in the pod
     * @param {string} tgtPath - The target path in local
     * @param {string} [cwd] - The directory that is used as the parent in the pod when downloading
     */ async cpFromPod(namespace, podName, containerName, srcPath, tgtPath, cwd) {
        const command = [
            'tar',
            'zcf',
            '-'
        ];
        if (cwd) {
            command.push('-C', cwd);
        }
        command.push(srcPath);
        const writerStream = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tar$2d$fs$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].extract(tgtPath);
        const errStream = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stream$2d$buffers$2f$lib$2f$streambuffer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["WritableStreamBuffer"]();
        this.execInstance.exec(namespace, podName, containerName, command, writerStream, errStream, null, false, async ()=>{
            if (errStream.size()) {
                throw new Error(`Error from cpFromPod - details: \n ${errStream.getContentsAsString()}`);
            }
        });
    }
    /**
     * @param {string} namespace - The namespace of the pod to exec the command inside.
     * @param {string} podName - The name of the pod to exec the command inside.
     * @param {string} containerName - The name of the container in the pod to exec the command inside.
     * @param {string} srcPath - The source path in local
     * @param {string} tgtPath - The target path in the pod
     */ async cpToPod(namespace, podName, containerName, srcPath, tgtPath) {
        const command = [
            'tar',
            'xf',
            '-',
            '-C',
            tgtPath
        ];
        const readStream = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$tar$2d$fs$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"].pack(srcPath);
        const errStream = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stream$2d$buffers$2f$lib$2f$streambuffer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["WritableStreamBuffer"]();
        this.execInstance.exec(namespace, podName, containerName, command, null, errStream, readStream, false, async ()=>{
            if (errStream.size()) {
                throw new Error(`Error from cpToPod - details: \n ${errStream.getContentsAsString()}`);
            }
        });
    }
} //# sourceMappingURL=cp.js.map
}),
"[project]/node_modules/@kubernetes/client-node/dist/patch.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Valid Content-Type header values for patch operations.  See
 * https://kubernetes.io/docs/tasks/run-application/update-api-object-kubectl-patch/
 * for details.
 *
 * Additionally for Server-Side Apply https://kubernetes.io/docs/reference/using-api/server-side-apply/
 * and https://kubernetes.io/docs/reference/using-api/server-side-apply/#api-implementation
 */ __turbopack_context__.s([
    "PatchStrategy",
    ()=>PatchStrategy
]);
const PatchStrategy = {
    /** Diff-like JSON format. */ JsonPatch: 'application/json-patch+json',
    /** Simple merge. */ MergePatch: 'application/merge-patch+json',
    /** Merge with different strategies depending on field metadata. */ StrategicMergePatch: 'application/strategic-merge-patch+json',
    /** Server-Side Apply */ ServerSideApply: 'application/apply-patch+yaml'
}; //# sourceMappingURL=patch.js.map
}),
"[project]/node_modules/@kubernetes/client-node/dist/metrics.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Metrics",
    ()=>Metrics
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/lib/index.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/gen/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$apis$2f$exception$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/gen/apis/exception.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/util.js [app-route] (ecmascript)");
;
;
;
class Metrics {
    constructor(config){
        this.config = config;
    }
    async getNodeMetrics() {
        return this.metricsApiRequest('/apis/metrics.k8s.io/v1beta1/nodes');
    }
    async getPodMetrics(namespace) {
        let path;
        if (namespace !== undefined && namespace.length > 0) {
            path = `/apis/metrics.k8s.io/v1beta1/namespaces/${namespace}/pods`;
        } else {
            path = '/apis/metrics.k8s.io/v1beta1/pods';
        }
        return this.metricsApiRequest(path);
    }
    async metricsApiRequest(path) {
        const cluster = this.config.getCurrentCluster();
        if (!cluster) {
            throw new Error('No currently active cluster');
        }
        const requestURL = cluster.server + path;
        const requestInit = await this.config.applyToFetchOptions({});
        requestInit.method = 'GET';
        try {
            const response = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(requestURL, requestInit);
            const json = await response.json();
            const { status } = response;
            if (status === 200) {
                return json;
            }
            if (status === 500) {
                const v1status = json;
                const v1code = v1status.code;
                const v1message = v1status.message;
                if (v1code !== undefined && v1message !== undefined) {
                    throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$apis$2f$exception$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ApiException"](v1code, v1message, v1status, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["normalizeResponseHeaders"])(response));
                }
            }
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$apis$2f$exception$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ApiException"](status, 'Error occurred in metrics request', undefined, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["normalizeResponseHeaders"])(response));
        } catch (e) {
            if (e instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$apis$2f$exception$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ApiException"]) {
                throw e;
            }
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$apis$2f$exception$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ApiException"](500, `Error occurred in metrics request: ${e.message}`, {}, {});
        }
    }
} //# sourceMappingURL=metrics.js.map
}),
"[project]/node_modules/@kubernetes/client-node/dist/object.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "KubernetesObjectApi",
    ()=>KubernetesObjectApi
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$api$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/api.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$apis$2f$exception$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/gen/apis/exception.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$http$2f$http$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/gen/http/http.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/serializer.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$rxjsStub$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/gen/rxjsStub.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$patch$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/patch.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/util.js [app-route] (ecmascript)");
;
;
;
;
;
class KubernetesObjectApi {
    /**
     * Create a KubernetesObjectApi object from the provided KubeConfig.  This method should be used rather than
     * [[KubeConfig.makeApiClient]] so we can properly determine the default namespace if one is provided by the current
     * context.
     *
     * @param kc Valid Kubernetes config
     * @return Properly instantiated [[KubernetesObjectApi]] object
     */ static makeApiClient(kc) {
        const client = kc.makeApiClient(KubernetesObjectApi);
        client.setDefaultNamespace(kc);
        return client;
    }
    constructor(configuration){
        /** Initialize the default namespace.  May be overwritten by context. */ this.defaultNamespace = 'default';
        /** Cache resource API response. */ this.apiVersionResourceCache = {};
        this.configuration = configuration;
    }
    /**
     * Create any Kubernetes resource.
     * @param spec Kubernetes resource spec.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized
     *        dryRun directive will result in an error response and no further processing of the request. Valid values
     *        are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The
     *        value must be less than or 128 characters long, and only contain printable characters, as defined by
     *        https://golang.org/pkg/unicode/#IsPrint.
     * @param options Optional headers to use in the request.
     * @return Promise containing the request response and [[KubernetesObject]].
     */ async create(spec, pretty, dryRun, fieldManager, options) {
        const _config = options || this.configuration;
        // verify required parameter 'spec' is not null or undefined
        if (spec === null || spec === undefined) {
            throw new Error('Required parameter spec was null or undefined when calling create.');
        }
        const localVarPath = await this.specUriPath(spec, 'create');
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$http$2f$http$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HttpMethod"].POST);
        requestContext.setHeaderParam('Accept', 'application/json, */*;q=0.8');
        if (pretty !== undefined) {
            requestContext.setQueryParam('pretty', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].serialize(pretty, 'string'));
        }
        if (dryRun !== undefined) {
            requestContext.setQueryParam('dryRun', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].serialize(dryRun, 'string'));
        }
        if (fieldManager !== undefined) {
            requestContext.setQueryParam('fieldManager', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].serialize(fieldManager, 'string'));
        }
        const type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getSerializationType"])(spec.apiVersion, spec.kind);
        // Body Params
        const contentType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].getPreferredMediaType([]);
        requestContext.setHeaderParam('Content-Type', contentType);
        const serializedBody = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].stringify(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].serialize(spec, type), contentType);
        requestContext.setBody(serializedBody);
        return this.requestPromise(requestContext);
    }
    /**
     * Delete any Kubernetes resource.
     * @param spec Kubernetes resource spec
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized
     *        dryRun directive will result in an error response and no further processing of the request. Valid values
     *        are: - All: all dry run stages will be processed
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative
     *        integer. The value zero indicates delete immediately. If this value is nil, the default grace period for
     *        the specified type will be used. Defaults to a per object value if not specified. zero means delete
     *        immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in
     *        1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be
     *        added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be
     *        set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or
     *        OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in
     *        the metadata.finalizers and the resource-specific default policy. Acceptable values are:
     *        \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete
     *        the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents
     *        in the foreground.
     * @param body See [[V1DeleteOptions]].
     * @param options Optional headers to use in the request.
     * @return Promise containing the request response and a Kubernetes [[V1Status]].
     */ async delete(spec, pretty, dryRun, gracePeriodSeconds, orphanDependents, propagationPolicy, body, options) {
        const _config = options || this.configuration;
        // verify required parameter 'spec' is not null or undefined
        if (spec === null || spec === undefined) {
            throw new Error('Required parameter spec was null or undefined when calling delete.');
        }
        const localVarPath = await this.specUriPath(spec, 'delete');
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$http$2f$http$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HttpMethod"].DELETE);
        requestContext.setHeaderParam('Accept', 'application/json, */*;q=0.8');
        if (pretty !== undefined) {
            requestContext.setQueryParam('pretty', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].serialize(pretty, 'string'));
        }
        if (dryRun !== undefined) {
            requestContext.setQueryParam('dryRun', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].serialize(dryRun, 'string'));
        }
        if (gracePeriodSeconds !== undefined) {
            requestContext.setQueryParam('gracePeriodSeconds', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].serialize(gracePeriodSeconds, 'number'));
        }
        if (orphanDependents !== undefined) {
            requestContext.setQueryParam('orphanDependents', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].serialize(orphanDependents, 'boolean'));
        }
        if (propagationPolicy !== undefined) {
            requestContext.setQueryParam('propagationPolicy', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].serialize(propagationPolicy, 'string'));
        }
        // Body Params
        if (body) {
            const contentType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].getPreferredMediaType([]);
            requestContext.setHeaderParam('Content-Type', contentType);
            const serializedBody = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].stringify(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].serialize(body, 'V1DeleteOptions'), contentType);
            requestContext.setBody(serializedBody);
        }
        return this.requestPromise(requestContext, 'V1Status');
    }
    /**
     * Patch any Kubernetes resource.
     * @param spec Kubernetes resource spec
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized
     *        dryRun directive will result in an error response and no further processing of the request. Valid values
     *        are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes.  The
     *        value must be less than or 128 characters long, and only contain printable characters, as defined by
     *        https://golang.org/pkg/unicode/#IsPrint. This field is required for apply requests
     *        (application/apply-patch) but optional for non-apply patch types (JsonPatch, MergePatch,
     *        StrategicMergePatch).
     * @param force Force is going to \&quot;force\&quot; Apply requests.  It means user will re-acquire conflicting
     *        fields owned by other people. Force flag must be unset for non-apply patch requests.
     * @param patchStrategy Content-Type header used to control how the patch will be performed. See
     *        See https://kubernetes.io/docs/tasks/run-application/update-api-object-kubectl-patch/
     *        for details.
     * @param options Optional headers to use in the request.
     * @return Promise containing the request response and [[KubernetesObject]].
     */ async patch(spec, pretty, dryRun, fieldManager, force, patchStrategy = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$patch$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["PatchStrategy"].StrategicMergePatch, options) {
        const _config = options || this.configuration;
        // verify required parameter 'spec' is not null or undefined
        if (spec === null || spec === undefined) {
            throw new Error('Required parameter spec was null or undefined when calling patch.');
        }
        const localVarPath = await this.specUriPath(spec, 'patch');
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$http$2f$http$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HttpMethod"].PATCH);
        requestContext.setHeaderParam('Accept', 'application/json, */*;q=0.8');
        requestContext.setHeaderParam('Content-Type', patchStrategy);
        if (pretty !== undefined) {
            requestContext.setQueryParam('pretty', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].serialize(pretty, 'string'));
        }
        if (dryRun !== undefined) {
            requestContext.setQueryParam('dryRun', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].serialize(dryRun, 'string'));
        }
        if (fieldManager !== undefined) {
            requestContext.setQueryParam('fieldManager', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].serialize(fieldManager, 'string'));
        }
        if (force !== undefined) {
            requestContext.setQueryParam('force', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].serialize(force, 'boolean'));
        }
        const type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getSerializationType"])(spec.apiVersion, spec.kind);
        // Body Params
        const serializedBody = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].stringify(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].serialize(spec, type), // TODO: use the patch content type once ObjectSerializer supports it.
        'application/json');
        requestContext.setBody(serializedBody);
        return this.requestPromise(requestContext);
    }
    /**
     * Read any Kubernetes resource.
     * @param spec Kubernetes resource spec
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like
     *        \&#39;Namespace\&#39;. Deprecated. Planned for removal in 1.18.
     * @param exportt Should this value be exported.  Export strips fields that a user can not
     *        specify. Deprecated. Planned for removal in 1.18.
     * @param options Optional headers to use in the request.
     * @return Promise containing the request response and [[KubernetesObject]].
     */ async read(spec, pretty, exact, exportt, options) {
        const _config = options || this.configuration;
        // verify required parameter 'spec' is not null or undefined
        if (spec === null || spec === undefined) {
            throw new Error('Required parameter spec was null or undefined when calling read.');
        }
        // verify required parameter 'kind' is not null or undefined
        if (spec.kind === null || spec.kind === undefined) {
            throw new Error('Required parameter spec.kind was null or undefined when calling read.');
        }
        if (!spec.apiVersion) {
            throw new Error('Required parameter spec.apiVersion was null or undefined when calling read.');
        }
        const localVarPath = await this.specUriPath(spec, 'read');
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$http$2f$http$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HttpMethod"].GET);
        requestContext.setHeaderParam('Accept', 'application/json, */*;q=0.8');
        if (pretty !== undefined) {
            requestContext.setQueryParam('pretty', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].serialize(pretty, 'string'));
        }
        if (exact !== undefined) {
            requestContext.setQueryParam('exact', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].serialize(exact, 'boolean'));
        }
        if (exportt !== undefined) {
            requestContext.setQueryParam('export', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].serialize(exportt, 'boolean'));
        }
        return this.requestPromise(requestContext);
    }
    /**
     * List any Kubernetes resources.
     * @param apiVersion api group and version of the form <apiGroup>/<version>
     * @param kind Kubernetes resource kind
     * @param namespace list resources in this namespace
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param exact Should the export be exact.  Exact export maintains cluster-specific fields like
     *        \&#39;Namespace\&#39;. Deprecated. Planned for removal in 1.18.
     * @param exportt Should this value be exported.  Export strips fields that a user can not
     *        specify. Deprecated. Planned for removal in 1.18.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit Number of returned resources.
     * @param options Optional headers to use in the request.
     * @return Promise containing the request response and [[KubernetesListObject<KubernetesObject>]].
     */ async list(apiVersion, kind, namespace, pretty, exact, exportt, fieldSelector, labelSelector, limit, continueToken, options) {
        const _config = options || this.configuration;
        // verify required parameters 'apiVersion', 'kind' is not null or undefined
        if (apiVersion === null || apiVersion === undefined) {
            throw new Error('Required parameter apiVersion was null or undefined when calling list.');
        }
        if (kind === null || kind === undefined) {
            throw new Error('Required parameter kind was null or undefined when calling list.');
        }
        const localVarPath = await this.specUriPath({
            apiVersion,
            kind,
            metadata: {
                namespace
            }
        }, 'list');
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$http$2f$http$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HttpMethod"].GET);
        requestContext.setHeaderParam('Accept', 'application/json, */*;q=0.8');
        if (pretty !== undefined) {
            requestContext.setQueryParam('pretty', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].serialize(pretty, 'string'));
        }
        if (exact !== undefined) {
            requestContext.setQueryParam('exact', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].serialize(exact, 'boolean'));
        }
        if (exportt !== undefined) {
            requestContext.setQueryParam('export', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].serialize(exportt, 'boolean'));
        }
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam('fieldSelector', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].serialize(fieldSelector, 'string'));
        }
        if (labelSelector !== undefined) {
            requestContext.setQueryParam('labelSelector', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].serialize(labelSelector, 'string'));
        }
        if (limit !== undefined) {
            requestContext.setQueryParam('limit', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].serialize(limit, 'number'));
        }
        if (continueToken !== undefined) {
            requestContext.setQueryParam('continue', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].serialize(continueToken, 'string'));
        }
        return this.requestPromise(requestContext);
    }
    /**
     * Replace any Kubernetes resource.
     * @param spec Kubernetes resource spec
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized
     *        dryRun directive will result in an error response and no further processing of the request. Valid values
     *        are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The
     *        value must be less than or 128 characters long, and only contain printable characters, as defined by
     *        https://golang.org/pkg/unicode/#IsPrint.
     * @param options Optional headers to use in the request.
     * @return Promise containing the request response and [[KubernetesObject]].
     */ async replace(spec, pretty, dryRun, fieldManager, options) {
        const _config = options || this.configuration;
        // verify required parameter 'spec' is not null or undefined
        if (spec === null || spec === undefined) {
            throw new Error('Required parameter spec was null or undefined when calling replace.');
        }
        const localVarPath = await this.specUriPath(spec, 'replace');
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$http$2f$http$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HttpMethod"].PUT);
        requestContext.setHeaderParam('Accept', 'application/json, */*;q=0.8');
        if (pretty !== undefined) {
            requestContext.setQueryParam('pretty', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].serialize(pretty, 'string'));
        }
        if (dryRun !== undefined) {
            requestContext.setQueryParam('dryRun', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].serialize(dryRun, 'string'));
        }
        if (fieldManager !== undefined) {
            requestContext.setQueryParam('fieldManager', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].serialize(fieldManager, 'string'));
        }
        const type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getSerializationType"])(spec.apiVersion, spec.kind);
        // Body Params
        const contentType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].getPreferredMediaType([]);
        requestContext.setHeaderParam('Content-Type', contentType);
        const serializedBody = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].stringify(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].serialize(spec, type), contentType);
        requestContext.setBody(serializedBody);
        return this.requestPromise(requestContext);
    }
    /** Set default namespace from current context, if available. */ setDefaultNamespace(kc) {
        if (kc.currentContext) {
            const currentContext = kc.getContextObject(kc.currentContext);
            if (currentContext && currentContext.namespace) {
                this.defaultNamespace = currentContext.namespace;
            }
        }
        return this.defaultNamespace;
    }
    /**
     * Use spec information to construct resource URI path.  If any required information in not provided, an Error is
     * thrown.  If an `apiVersion` is not provided, 'v1' is used.  If a `metadata.namespace` is not provided for a
     * request that requires one, the context default is used, if available, if not, 'default' is used.
     *
     * @param spec Kubernetes resource spec which must define kind and apiVersion properties.
     * @param action API action, see [[K8sApiAction]].
     * @return tail of resource-specific URI
     */ async specUriPath(spec, action) {
        if (!spec.kind) {
            throw new Error('Required spec property kind is not set');
        }
        if (!spec.apiVersion) {
            spec.apiVersion = 'v1';
        }
        if (!spec.metadata) {
            spec.metadata = {};
        }
        const resource = await this.resource(spec.apiVersion, spec.kind);
        if (!resource) {
            throw new Error(`Unrecognized API version and kind: ${spec.apiVersion} ${spec.kind}`);
        }
        if (resource.namespaced && !spec.metadata.namespace && action !== 'list') {
            spec.metadata.namespace = this.defaultNamespace;
        }
        const parts = [
            this.apiVersionPath(spec.apiVersion)
        ];
        if (resource.namespaced && spec.metadata.namespace) {
            parts.push('namespaces', encodeURIComponent(String(spec.metadata.namespace)));
        }
        parts.push(resource.name);
        if (action !== 'create' && action !== 'list') {
            if (!spec.metadata.name) {
                throw new Error('Required spec property name is not set');
            }
            parts.push(encodeURIComponent(String(spec.metadata.name)));
        }
        return parts.join('/').toLowerCase();
    }
    /** Return root of API path up to API version. */ apiVersionPath(apiVersion) {
        const api = apiVersion.includes('/') ? 'apis' : 'api';
        return '/' + [
            api,
            apiVersion
        ].join('/');
    }
    /**
     * Get metadata from Kubernetes API for resources described by `kind` and `apiVersion`.  If it is unable to find the
     * resource `kind` under the provided `apiVersion`, `undefined` is returned.
     *
     * This method caches responses from the Kubernetes API to use for future requests.  If the cache for apiVersion
     * exists but the kind is not found the request is attempted again.
     *
     * @param apiVersion Kubernetes API version, e.g., 'v1' or 'apps/v1'.
     * @param kind Kubernetes resource kind, e.g., 'Pod' or 'Namespace'.
     * @return Promise of the resource metadata or `undefined` if the resource is not found.
     */ async resource(apiVersion, kind, options) {
        const _config = options || this.configuration;
        // verify required parameter 'apiVersion' is not null or undefined
        if (apiVersion === null || apiVersion === undefined) {
            throw new Error('Required parameter apiVersion was null or undefined when calling resource');
        }
        // verify required parameter 'kind' is not null or undefined
        if (kind === null || kind === undefined) {
            throw new Error('Required parameter kind was null or undefined when calling resource');
        }
        if (this.apiVersionResourceCache[apiVersion]) {
            const resource = this.apiVersionResourceCache[apiVersion].resources.find((r)=>r.kind === kind);
            if (resource) {
                return resource;
            }
        }
        const localVarPath = this.apiVersionPath(apiVersion);
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$http$2f$http$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["HttpMethod"].GET);
        requestContext.setHeaderParam('Accept', 'application/json, */*;q=0.8');
        try {
            const getApiResponse = await this.requestPromise(requestContext, 'V1APIResourceList');
            this.apiVersionResourceCache[apiVersion] = getApiResponse;
            return this.apiVersionResourceCache[apiVersion].resources.find((r)=>r.kind === kind);
        } catch (e) {
            if (e instanceof Error) {
                e.message = `Failed to fetch resource metadata for ${apiVersion}/${kind}: ${e.message}`;
            }
            throw e;
        }
    }
    async requestPromise(requestContext, type, options) {
        var _a, _b, _c;
        const _config = options || this.configuration;
        // Apply auth methods
        const authMethod = _config.authMethods.BearerToken;
        if (authMethod === null || authMethod === void 0 ? void 0 : authMethod.applySecurityAuthentication) {
            await (authMethod === null || authMethod === void 0 ? void 0 : authMethod.applySecurityAuthentication(requestContext));
        }
        const defaultAuth = ((_a = options === null || options === void 0 ? void 0 : options.authMethods) === null || _a === void 0 ? void 0 : _a.default) || ((_c = (_b = this.configuration) === null || _b === void 0 ? void 0 : _b.authMethods) === null || _c === void 0 ? void 0 : _c.default);
        if (defaultAuth === null || defaultAuth === void 0 ? void 0 : defaultAuth.applySecurityAuthentication) {
            await (defaultAuth === null || defaultAuth === void 0 ? void 0 : defaultAuth.applySecurityAuthentication(requestContext));
        }
        // build promise chain
        let middlewarePreObservable = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$rxjsStub$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["from"])(Promise.resolve(requestContext));
        for (const middleware of this.configuration.middleware){
            middlewarePreObservable = middlewarePreObservable.pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$rxjsStub$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["mergeMap"])((ctx)=>middleware.pre(ctx)));
        }
        return middlewarePreObservable.pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$rxjsStub$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["mergeMap"])((ctx)=>this.configuration.httpApi.send(ctx))).pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$rxjsStub$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["mergeMap"])((response)=>{
            let middlewarePostObservable = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$rxjsStub$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["of"])(response);
            for (const middleware of this.configuration.middleware){
                middlewarePostObservable = middlewarePostObservable.pipe((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$rxjsStub$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["mergeMap"])((rsp)=>middleware.post(rsp)));
            }
            return middlewarePostObservable.pipe((rsp)=>this.processResponse(rsp, type));
        })).toPromise();
    }
    async processResponse(response, type) {
        const contentType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].normalizeMediaType(response.headers['content-type']);
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const data = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].parse(await response.body.text(), contentType);
            if (type === undefined) {
                type = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$util$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getSerializationType"])(data.apiVersion, data.kind);
            }
            if (!type) {
                throw new Error('Unable to determine type of Kubernetes type of response.');
            }
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$serializer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ObjectSerializer"].deserialize(data, type);
        }
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$apis$2f$exception$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ApiException"](response.httpStatusCode, 'Unsuccessful HTTP Request', await response.getBodyAsAny(), response.headers);
    }
} //# sourceMappingURL=object.js.map
}),
"[project]/node_modules/@kubernetes/client-node/dist/health.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Health",
    ()=>Health
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/lib/index.mjs [app-route] (ecmascript)");
;
class Health {
    constructor(config){
        this.config = config;
    }
    async readyz(opts) {
        return this.check('/readyz', opts);
    }
    async livez(opts) {
        return this.check('/livez', opts);
    }
    async healthz(opts) {
        return this.check('/healthz', opts);
    }
    async check(path, opts) {
        const cluster = this.config.getCurrentCluster();
        if (!cluster) {
            throw new Error('No currently active cluster');
        }
        const requestURL = new URL(cluster.server + path);
        const requestInit = await this.config.applyToFetchOptions(opts);
        if (opts.signal) {
            requestInit.signal = opts.signal;
        }
        requestInit.method = 'GET';
        try {
            const response = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"])(requestURL.toString(), requestInit);
            const status = response.status;
            if (status === 200) {
                return true;
            }
            if (status === 404) {
                if (path === '/healthz') {
                    // /livez/readyz return 404 and healthz also returns 404, let's consider it is live
                    return true;
                }
                return this.healthz(opts);
            }
            return false;
        } catch (err) {
            if (err.name === 'AbortError') {
                throw err;
            }
            throw new Error('Error occurred in health request');
        }
    }
} //# sourceMappingURL=health.js.map
}),
"[project]/node_modules/@kubernetes/client-node/dist/middleware.js [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "setHeaderMiddleware",
    ()=>setHeaderMiddleware,
    "setHeaderOptions",
    ()=>setHeaderOptions
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$rxjsStub$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/gen/rxjsStub.js [app-route] (ecmascript)");
;
function setHeaderMiddleware(key, value) {
    return {
        pre: (request)=>{
            request.setHeaderParam(key, value);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$rxjsStub$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["of"])(request);
        },
        post: (response)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$rxjsStub$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["of"])(response);
        }
    };
}
function setHeaderOptions(key, value, opt) {
    const newMiddlware = setHeaderMiddleware(key, value);
    const existingMiddlware = (opt === null || opt === void 0 ? void 0 : opt.middleware) || [];
    return {
        ...opt,
        middleware: existingMiddlware.concat(newMiddlware),
        middlewareMergeStrategy: 'append'
    };
} //# sourceMappingURL=middleware.js.map
}),
"[project]/node_modules/@kubernetes/client-node/dist/index.js [app-route] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$config$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/config.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$cache$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/cache.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$api$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/api.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$attach$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/attach.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$watch$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/watch.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$exec$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/exec.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$portforward$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/portforward.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$types$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/types.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$yaml$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/yaml.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$log$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/log.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$informer$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/informer.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$top$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/top.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$cp$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/cp.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$patch$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/patch.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$metrics$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/metrics.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$object$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/object.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$health$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/health.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$middleware$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/middleware.js [app-route] (ecmascript)");
// Export AbortError and FetchError so that instanceof checks in user code will definitely use the same instances
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$node$2d$fetch$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/node-fetch/lib/index.mjs [app-route] (ecmascript)"); //# sourceMappingURL=index.js.map
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
}),
];

//# sourceMappingURL=node_modules_%40kubernetes_client-node_dist_7ffe0ecd._.js.map