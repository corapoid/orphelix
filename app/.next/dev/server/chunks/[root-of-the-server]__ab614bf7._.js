module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/node:fs [external] (node:fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:fs", () => require("node:fs"));

module.exports = mod;
}),
"[externals]/node:https [external] (node:https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:https", () => require("node:https"));

module.exports = mod;
}),
"[externals]/node:http [external] (node:http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:http", () => require("node:http"));

module.exports = mod;
}),
"[externals]/node:net [external] (node:net, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:net", () => require("node:net"));

module.exports = mod;
}),
"[externals]/node:path [external] (node:path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:path", () => require("node:path"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/http [external] (http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/punycode [external] (punycode, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("punycode", () => require("punycode"));

module.exports = mod;
}),
"[externals]/https [external] (https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}),
"[externals]/zlib [external] (zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}),
"[externals]/node:child_process [external] (node:child_process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:child_process", () => require("node:child_process"));

module.exports = mod;
}),
"[externals]/vm [external] (vm, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("vm", () => require("vm"));

module.exports = mod;
}),
"[externals]/events [external] (events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}),
"[externals]/net [external] (net, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}),
"[externals]/buffer [external] (buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}),
"[externals]/tty [external] (tty, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tty", () => require("tty"));

module.exports = mod;
}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/os [external] (os, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}),
"[externals]/dns [external] (dns, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("dns", () => require("dns"));

module.exports = mod;
}),
"[externals]/tls [external] (tls, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}),
"[externals]/node:readline [external] (node:readline, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:readline", () => require("node:readline"));

module.exports = mod;
}),
"[externals]/node:querystring [external] (node:querystring, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:querystring", () => require("node:querystring"));

module.exports = mod;
}),
"[externals]/node:stream [external] (node:stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:stream", () => require("node:stream"));

module.exports = mod;
}),
"[externals]/crypto [external] (crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}),
"[externals]/fs [external] (fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}),
"[externals]/path [external] (path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}),
"[project]/app/lib/k8s/client.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Kubernetes Client Configuration
 *
 * This module provides a configured Kubernetes client for interacting with
 * a Kubernetes cluster. It supports multiple authentication methods:
 * - Kubeconfig file (~/.kube/config)
 * - In-cluster configuration (for running inside a pod)
 * - Manual configuration
 */ __turbopack_context__.s([
    "checkConnection",
    ()=>checkConnection,
    "getAppsApi",
    ()=>getAppsApi,
    "getAutoscalingApi",
    ()=>getAutoscalingApi,
    "getBatchApi",
    ()=>getBatchApi,
    "getCoreApi",
    ()=>getCoreApi,
    "getEventsApi",
    ()=>getEventsApi,
    "getKubeConfig",
    ()=>getKubeConfig,
    "getNetworkingApi",
    ()=>getNetworkingApi,
    "initK8sClient",
    ()=>initK8sClient,
    "resetClient",
    ()=>resetClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$config$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/config.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/gen/index.js [app-route] (ecmascript)");
;
let kc = null;
let k8sAppsApi = null;
let k8sCoreApi = null;
let k8sAutoscalingApi = null;
let k8sEventsApi = null;
let k8sNetworkingApi = null;
let k8sBatchApi = null;
function initK8sClient(contextName) {
    // Reset client to force reload (needed for AWS EKS exec auth)
    kc = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$config$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["KubeConfig"]();
    // Always use kubeconfig file for development (not in-cluster)
    // In-cluster config is only for when running inside Kubernetes pod
    try {
        // Load from kubeconfig file (~/.kube/config)
        kc.loadFromDefault();
        // Switch to specified context if provided
        if (contextName) {
            kc.setCurrentContext(contextName);
        }
        const cluster = kc.getCurrentCluster();
        const currentCtx = kc.getCurrentContext();
        // Validate cluster configuration
        if (!cluster?.server) {
            throw new Error(`Cluster server URL is not configured for context: ${contextName || currentCtx}`);
        }
    } catch (error) {
        console.error('[K8s] Failed to load Kubernetes configuration:', error);
        throw new Error('Failed to initialize Kubernetes client. Make sure kubeconfig is properly configured.');
    }
    // Initialize API clients (recreate on every call for fresh tokens)
    k8sAppsApi = kc.makeApiClient(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AppsV1Api"]);
    k8sCoreApi = kc.makeApiClient(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CoreV1Api"]);
    k8sAutoscalingApi = kc.makeApiClient(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AutoscalingV2Api"]);
    k8sEventsApi = kc.makeApiClient(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EventsV1Api"]);
    k8sNetworkingApi = kc.makeApiClient(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NetworkingV1Api"]);
    k8sBatchApi = kc.makeApiClient(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BatchV1Api"]);
}
function getAppsApi(contextName) {
    // Always reinitialize for AWS EKS to refresh tokens
    initK8sClient(contextName);
    return k8sAppsApi;
}
function getCoreApi(contextName) {
    // Always reinitialize for AWS EKS to refresh tokens
    initK8sClient(contextName);
    return k8sCoreApi;
}
function getAutoscalingApi(contextName) {
    // Always reinitialize for AWS EKS to refresh tokens
    initK8sClient(contextName);
    return k8sAutoscalingApi;
}
function getEventsApi(contextName) {
    // Always reinitialize for AWS EKS to refresh tokens
    initK8sClient(contextName);
    return k8sEventsApi;
}
function getNetworkingApi(contextName) {
    // Always reinitialize for AWS EKS to refresh tokens
    initK8sClient(contextName);
    return k8sNetworkingApi;
}
function getBatchApi(contextName) {
    // Always reinitialize for AWS EKS to refresh tokens
    initK8sClient(contextName);
    return k8sBatchApi;
}
function getKubeConfig() {
    if (!kc) {
        initK8sClient();
    }
    return kc;
}
async function checkConnection() {
    try {
        const coreApi = getCoreApi();
        await coreApi.listNamespace();
        return true;
    } catch (error) {
        console.error('[K8s] Connection check failed:', error);
        return false;
    }
}
function resetClient() {
    kc = null;
    k8sAppsApi = null;
    k8sCoreApi = null;
    k8sAutoscalingApi = null;
    k8sEventsApi = null;
    k8sNetworkingApi = null;
    k8sBatchApi = null;
}
}),
"[project]/app/app/api/cluster/health/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GET",
    ()=>GET,
    "dynamic",
    ()=>dynamic
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$app$2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/app/lib/k8s/client.ts [app-route] (ecmascript)");
;
;
const dynamic = 'force-dynamic';
async function GET() {
    try {
        const coreV1Api = (0, __TURBOPACK__imported__module__$5b$project$5d2f$app$2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCoreApi"])();
        // Try to list namespaces as a health check
        // This is a lightweight operation that requires basic cluster access
        await coreV1Api.listNamespace();
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            status: 'connected',
            message: 'Successfully connected to Kubernetes cluster'
        });
    } catch (error) {
        console.error('[Health Check] Cluster connection failed:', error);
        const err = error;
        const statusCode = err.code || 500;
        const message = err.body?.message || err.message || 'Unknown error';
        // Return specific error information
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
            status: 'disconnected',
            message: statusCode === 401 ? 'Unauthorized: Invalid or expired cluster credentials' : statusCode === 403 ? 'Forbidden: Insufficient permissions to access cluster' : statusCode === 404 ? 'Cluster not found: Check your kubeconfig' : `Failed to connect to cluster: ${message}`,
            code: statusCode
        }, {
            status: 200
        } // Return 200 so the client can handle the disconnected state
        );
    }
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__ab614bf7._.js.map