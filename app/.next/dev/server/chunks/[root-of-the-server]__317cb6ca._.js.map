{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 34, "column": 0}, "map": {"version":3,"sources":["file:///Users/dmakowski/git_priv/kubevista/app/lib/github/client.ts"],"sourcesContent":["import { Octokit } from '@octokit/rest'\n\nexport interface YamlFile {\n  name: string\n  path: string\n  sha: string\n  type: 'file' | 'dir'\n}\n\nexport interface KustomizeStructure {\n  hasKustomization: boolean\n  basePath: string | null\n  overlays: string[]\n  baseFiles: YamlFile[]\n  overlayFiles: Record<string, YamlFile[]>\n}\n\nexport class GitHubClient {\n  private octokit: Octokit\n\n  constructor(accessToken: string) {\n    this.octokit = new Octokit({ auth: accessToken })\n  }\n\n  /**\n   * List user's repositories\n   */\n  async listRepositories(): Promise<Array<{ owner: string; repo: string; fullName: string; defaultBranch: string }>> {\n    const { data } = await this.octokit.repos.listForAuthenticatedUser({\n      sort: 'updated',\n      per_page: 100,\n    })\n\n    return data.map((repo) => ({\n      owner: repo.owner.login,\n      repo: repo.name,\n      fullName: repo.full_name,\n      defaultBranch: repo.default_branch || 'main',\n    }))\n  }\n\n  /**\n   * List YAML files in repository (recursive)\n   */\n  async listYamlFiles(\n    owner: string,\n    repo: string,\n    path: string = '',\n    ref: string = 'main'\n  ): Promise<YamlFile[]> {\n    const files: YamlFile[] = []\n\n    try {\n      const { data } = await this.octokit.repos.getContent({\n        owner,\n        repo,\n        path,\n        ref,\n      })\n\n      if (Array.isArray(data)) {\n        for (const item of data) {\n          if (item.type === 'file' && (item.name.endsWith('.yaml') || item.name.endsWith('.yml'))) {\n            files.push({\n              name: item.name,\n              path: item.path,\n              sha: item.sha!,\n              type: 'file',\n            })\n          } else if (item.type === 'dir') {\n            // Recursively search subdirectories\n            const subFiles = await this.listYamlFiles(owner, repo, item.path, ref)\n            files.push(...subFiles)\n          }\n        }\n      }\n    } catch (error) {\n      console.error(`Error listing files in ${path}:`, error)\n    }\n\n    return files\n  }\n\n  /**\n   * Get file content\n   */\n  async getFileContent(\n    owner: string,\n    repo: string,\n    path: string,\n    ref: string = 'main'\n  ): Promise<{ content: string; sha: string }> {\n    const { data } = await this.octokit.repos.getContent({\n      owner,\n      repo,\n      path,\n      ref,\n    })\n\n    if ('content' in data && data.type === 'file') {\n      const content = Buffer.from(data.content, 'base64').toString('utf-8')\n      return { content, sha: data.sha }\n    }\n\n    throw new Error('Path is not a file')\n  }\n\n  /**\n   * Detect if directory contains kustomization.yaml\n   */\n  async detectKustomization(owner: string, repo: string, dirPath: string, ref: string = 'main'): Promise<boolean> {\n    try {\n      const { data } = await this.octokit.repos.getContent({\n        owner,\n        repo,\n        path: dirPath,\n        ref,\n      })\n\n      if (Array.isArray(data)) {\n        return data.some(\n          (item) =>\n            item.type === 'file' &&\n            (item.name === 'kustomization.yaml' || item.name === 'kustomization.yml')\n        )\n      }\n\n      return false\n    } catch {\n      return false\n    }\n  }\n\n  /**\n   * Get Kustomize structure (base + overlays)\n   */\n  async getKustomizeStructure(\n    owner: string,\n    repo: string,\n    filePath: string,\n    ref: string = 'main'\n  ): Promise<KustomizeStructure> {\n    const dirPath = filePath.substring(0, filePath.lastIndexOf('/'))\n    const hasKustomization = await this.detectKustomization(owner, repo, dirPath, ref)\n\n    if (!hasKustomization) {\n      return {\n        hasKustomization: false,\n        basePath: null,\n        overlays: [],\n        baseFiles: [],\n        overlayFiles: {},\n      }\n    }\n\n    // Check if this is a base or overlay directory\n    const isBase = dirPath.endsWith('/base') || !dirPath.includes('overlay')\n    let basePath: string\n    let overlayParentPath: string\n\n    if (isBase) {\n      basePath = dirPath\n      overlayParentPath = dirPath.replace('/base', '/overlays')\n    } else {\n      // We're in an overlay\n      const overlayMatch = dirPath.match(/(.*)\\/overlays\\/([^/]+)/)\n      if (overlayMatch) {\n        basePath = `${overlayMatch[1]}/base`\n        overlayParentPath = `${overlayMatch[1]}/overlays`\n      } else {\n        basePath = dirPath\n        overlayParentPath = `${dirPath}/overlays`\n      }\n    }\n\n    // Get base files\n    const baseFiles = await this.listYamlFiles(owner, repo, basePath, ref)\n\n    // Get overlay directories\n    const overlays: string[] = []\n    const overlayFiles: Record<string, YamlFile[]> = {}\n\n    try {\n      const { data: overlayData } = await this.octokit.repos.getContent({\n        owner,\n        repo,\n        path: overlayParentPath,\n        ref,\n      })\n\n      if (Array.isArray(overlayData)) {\n        const overlayDirs = overlayData.filter((item) => item.type === 'dir').map((item) => item.name)\n        overlays.push(...overlayDirs)\n\n        // Get files for each overlay\n        for (const overlay of overlayDirs) {\n          const overlayPath = `${overlayParentPath}/${overlay}`\n          overlayFiles[overlay] = await this.listYamlFiles(owner, repo, overlayPath, ref)\n        }\n      }\n    } catch {\n      // No overlays directory - this is fine\n    }\n\n    return {\n      hasKustomization: true,\n      basePath,\n      overlays,\n      baseFiles,\n      overlayFiles,\n    }\n  }\n\n  /**\n   * Merge a pull request\n   */\n  async mergePullRequest(\n    owner: string,\n    repo: string,\n    pullNumber: number,\n    mergeMethod: 'merge' | 'squash' | 'rebase' = 'merge'\n  ): Promise<{ merged: boolean; message: string }> {\n    try {\n      const { data } = await this.octokit.pulls.merge({\n        owner,\n        repo,\n        pull_number: pullNumber,\n        merge_method: mergeMethod,\n      })\n\n      return {\n        merged: true,\n        message: data.message,\n      }\n    } catch (error: any) {\n      return {\n        merged: false,\n        message: error.message || 'Failed to merge PR',\n      }\n    }\n  }\n\n  /**\n   * List all branches in a repository\n   */\n  async listBranches(owner: string, repo: string): Promise<Array<{ name: string; protected: boolean }>> {\n    const { data } = await this.octokit.repos.listBranches({\n      owner,\n      repo,\n      per_page: 100,\n    })\n\n    return data.map((branch) => ({\n      name: branch.name,\n      protected: branch.protected,\n    }))\n  }\n\n  /**\n   * Get full repository tree (all files and directories)\n   */\n  async getRepositoryTree(\n    owner: string,\n    repo: string,\n    ref: string = 'main',\n    path: string = ''\n  ): Promise<Array<{ name: string; path: string; type: 'file' | 'dir'; size?: number }>> {\n    try {\n      const { data } = await this.octokit.repos.getContent({\n        owner,\n        repo,\n        path,\n        ref,\n      })\n\n      if (!Array.isArray(data)) {\n        // Single file\n        return [{\n          name: data.name,\n          path: data.path,\n          type: 'file',\n          size: data.size,\n        }]\n      }\n\n      // Directory - return all items\n      return data.map((item) => ({\n        name: item.name,\n        path: item.path,\n        type: item.type === 'dir' ? 'dir' : 'file',\n        size: item.type === 'file' ? item.size : undefined,\n      }))\n    } catch (error) {\n      console.error(`Error getting tree for ${path}:`, error)\n      return []\n    }\n  }\n\n  /**\n   * Create a new branch\n   */\n  async createBranch(\n    owner: string,\n    repo: string,\n    baseBranch: string,\n    newBranch: string\n  ): Promise<void> {\n    const { data: ref } = await this.octokit.git.getRef({\n      owner,\n      repo,\n      ref: `heads/${baseBranch}`,\n    })\n\n    await this.octokit.git.createRef({\n      owner,\n      repo,\n      ref: `refs/heads/${newBranch}`,\n      sha: ref.object.sha,\n    })\n  }\n\n  /**\n   * Commit file changes\n   */\n  async commitFile(\n    owner: string,\n    repo: string,\n    branch: string,\n    path: string,\n    content: string,\n    sha: string,\n    message: string\n  ): Promise<void> {\n    await this.octokit.repos.createOrUpdateFileContents({\n      owner,\n      repo,\n      path,\n      message,\n      content: Buffer.from(content).toString('base64'),\n      branch,\n      sha,\n    })\n  }\n\n  /**\n   * Create Pull Request\n   */\n  async createPullRequest(\n    owner: string,\n    repo: string,\n    title: string,\n    head: string,\n    base: string,\n    body: string\n  ): Promise<{ number: number; url: string }> {\n    const { data } = await this.octokit.pulls.create({\n      owner,\n      repo,\n      title,\n      head,\n      base,\n      body,\n    })\n\n    return {\n      number: data.number,\n      url: data.html_url,\n    }\n  }\n\n  /**\n   * Check if PR is merged\n   */\n  async isPullRequestMerged(owner: string, repo: string, prNumber: number): Promise<boolean> {\n    try {\n      await this.octokit.pulls.checkIfMerged({\n        owner,\n        repo,\n        pull_number: prNumber,\n      })\n      return true\n    } catch {\n      return false\n    }\n  }\n\n  /**\n   * List open PRs for a specific file\n   */\n  async getOpenPRsForFile(\n    owner: string,\n    repo: string,\n    filePath: string\n  ): Promise<Array<{ number: number; title: string; url: string }>> {\n    const { data: pulls } = await this.octokit.pulls.list({\n      owner,\n      repo,\n      state: 'open',\n      per_page: 100,\n    })\n\n    const prsForFile = []\n\n    for (const pull of pulls) {\n      const { data: files } = await this.octokit.pulls.listFiles({\n        owner,\n        repo,\n        pull_number: pull.number,\n      })\n\n      if (files.some((file) => file.filename === filePath)) {\n        prsForFile.push({\n          number: pull.number,\n          title: pull.title,\n          url: pull.html_url,\n        })\n      }\n    }\n\n    return prsForFile\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 355, "column": 0}, "map": {"version":3,"sources":["file:///Users/dmakowski/git_priv/kubevista/app/lib/github/get-token.ts"],"sourcesContent":["import { cookies } from 'next/headers'\n\n/**\n * Get GitHub App token from cookies\n * Returns the GitHub App installation token\n */\nexport async function getGitHubToken(): Promise<string | null> {\n  const cookieStore = await cookies()\n  const githubAppToken = cookieStore.get('github_app_token')?.value\n\n  return githubAppToken || null\n}\n"],"names":[],"mappings":";;;;AAAA;;AAMO,eAAe;IACpB,MAAM,cAAc,MAAM,IAAA,4IAAO;IACjC,MAAM,iBAAiB,YAAY,GAAG,CAAC,qBAAqB;IAE5D,OAAO,kBAAkB;AAC3B"}},
    {"offset": {"line": 370, "column": 0}, "map": {"version":3,"sources":["file:///Users/dmakowski/git_priv/kubevista/app/app/api/github/branches/route.ts"],"sourcesContent":["import { GitHubClient } from '@/lib/github/client'\nimport { NextRequest, NextResponse } from 'next/server'\nimport { getGitHubToken } from '@/lib/github/get-token'\n\nexport async function GET(request: NextRequest) {\n  try {\n    const token = await getGitHubToken()\n\n    if (!token) {\n      return NextResponse.json({ error: 'Unauthorized - Please connect GitHub' }, { status: 401 })\n    }\n\n    const { searchParams } = new URL(request.url)\n    const owner = searchParams.get('owner')\n    const repo = searchParams.get('repo')\n\n    if (!owner || !repo) {\n      return NextResponse.json({ error: 'owner and repo are required' }, { status: 400 })\n    }\n\n    const github = new GitHubClient(token)\n    const branches = await github.listBranches(owner, repo)\n\n    return NextResponse.json(branches)\n  } catch (error) {\n    console.error('Failed to fetch branches:', error)\n    return NextResponse.json({ error: 'Failed to fetch branches' }, { status: 500 })\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    const token = await getGitHubToken()\n\n    if (!token) {\n      return NextResponse.json({ error: 'Unauthorized - Please connect GitHub' }, { status: 401 })\n    }\n\n    const body = await request.json()\n    const { owner, repo, baseBranch, newBranch } = body\n\n    if (!owner || !repo || !baseBranch || !newBranch) {\n      return NextResponse.json(\n        { error: 'owner, repo, baseBranch, and newBranch are required' },\n        { status: 400 }\n      )\n    }\n\n    const github = new GitHubClient(token)\n    await github.createBranch(owner, repo, baseBranch, newBranch)\n\n    return NextResponse.json({ success: true, branch: newBranch })\n  } catch (error: any) {\n    console.error('Failed to create branch:', error)\n    return NextResponse.json(\n      { error: error.message || 'Failed to create branch' },\n      { status: 500 }\n    )\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;;;;AAEO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,MAAM,QAAQ,MAAM,IAAA,wJAAc;QAElC,IAAI,CAAC,OAAO;YACV,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAuC,GAAG;gBAAE,QAAQ;YAAI;QAC5F;QAEA,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;QAC5C,MAAM,QAAQ,aAAa,GAAG,CAAC;QAC/B,MAAM,OAAO,aAAa,GAAG,CAAC;QAE9B,IAAI,CAAC,SAAS,CAAC,MAAM;YACnB,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAA8B,GAAG;gBAAE,QAAQ;YAAI;QACnF;QAEA,MAAM,SAAS,IAAI,gJAAY,CAAC;QAChC,MAAM,WAAW,MAAM,OAAO,YAAY,CAAC,OAAO;QAElD,OAAO,gJAAY,CAAC,IAAI,CAAC;IAC3B,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,6BAA6B;QAC3C,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAA2B,GAAG;YAAE,QAAQ;QAAI;IAChF;AACF;AAEO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,QAAQ,MAAM,IAAA,wJAAc;QAElC,IAAI,CAAC,OAAO;YACV,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAuC,GAAG;gBAAE,QAAQ;YAAI;QAC5F;QAEA,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,EAAE,KAAK,EAAE,IAAI,EAAE,UAAU,EAAE,SAAS,EAAE,GAAG;QAE/C,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,cAAc,CAAC,WAAW;YAChD,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAsD,GAC/D;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,SAAS,IAAI,gJAAY,CAAC;QAChC,MAAM,OAAO,YAAY,CAAC,OAAO,MAAM,YAAY;QAEnD,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,SAAS;YAAM,QAAQ;QAAU;IAC9D,EAAE,OAAO,OAAY;QACnB,QAAQ,KAAK,CAAC,4BAA4B;QAC1C,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO,MAAM,OAAO,IAAI;QAA0B,GACpD;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}