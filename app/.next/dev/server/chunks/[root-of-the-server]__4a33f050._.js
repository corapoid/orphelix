module.exports = [
"[externals]/next/dist/compiled/next-server/app-route-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-route-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-route-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/compiled/next-server/app-page-turbo.runtime.dev.js [external] (next/dist/compiled/next-server/app-page-turbo.runtime.dev.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js", () => require("next/dist/compiled/next-server/app-page-turbo.runtime.dev.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-unit-async-storage.external.js [external] (next/dist/server/app-render/work-unit-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-unit-async-storage.external.js", () => require("next/dist/server/app-render/work-unit-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/work-async-storage.external.js [external] (next/dist/server/app-render/work-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/work-async-storage.external.js", () => require("next/dist/server/app-render/work-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/shared/lib/no-fallback-error.external.js [external] (next/dist/shared/lib/no-fallback-error.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/shared/lib/no-fallback-error.external.js", () => require("next/dist/shared/lib/no-fallback-error.external.js"));

module.exports = mod;
}),
"[externals]/next/dist/server/app-render/after-task-async-storage.external.js [external] (next/dist/server/app-render/after-task-async-storage.external.js, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("next/dist/server/app-render/after-task-async-storage.external.js", () => require("next/dist/server/app-render/after-task-async-storage.external.js"));

module.exports = mod;
}),
"[externals]/node:fs [external] (node:fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:fs", () => require("node:fs"));

module.exports = mod;
}),
"[externals]/node:https [external] (node:https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:https", () => require("node:https"));

module.exports = mod;
}),
"[externals]/node:http [external] (node:http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:http", () => require("node:http"));

module.exports = mod;
}),
"[externals]/node:net [external] (node:net, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:net", () => require("node:net"));

module.exports = mod;
}),
"[externals]/node:path [external] (node:path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:path", () => require("node:path"));

module.exports = mod;
}),
"[externals]/stream [external] (stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("stream", () => require("stream"));

module.exports = mod;
}),
"[externals]/http [external] (http, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("http", () => require("http"));

module.exports = mod;
}),
"[externals]/url [external] (url, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("url", () => require("url"));

module.exports = mod;
}),
"[externals]/punycode [external] (punycode, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("punycode", () => require("punycode"));

module.exports = mod;
}),
"[externals]/https [external] (https, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("https", () => require("https"));

module.exports = mod;
}),
"[externals]/zlib [external] (zlib, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("zlib", () => require("zlib"));

module.exports = mod;
}),
"[externals]/buffer [external] (buffer, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("buffer", () => require("buffer"));

module.exports = mod;
}),
"[externals]/string_decoder [external] (string_decoder, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("string_decoder", () => require("string_decoder"));

module.exports = mod;
}),
"[externals]/node:child_process [external] (node:child_process, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:child_process", () => require("node:child_process"));

module.exports = mod;
}),
"[externals]/vm [external] (vm, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("vm", () => require("vm"));

module.exports = mod;
}),
"[externals]/events [external] (events, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("events", () => require("events"));

module.exports = mod;
}),
"[externals]/net [external] (net, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("net", () => require("net"));

module.exports = mod;
}),
"[externals]/tty [external] (tty, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tty", () => require("tty"));

module.exports = mod;
}),
"[externals]/util [external] (util, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("util", () => require("util"));

module.exports = mod;
}),
"[externals]/os [external] (os, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("os", () => require("os"));

module.exports = mod;
}),
"[externals]/dns [external] (dns, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("dns", () => require("dns"));

module.exports = mod;
}),
"[externals]/tls [external] (tls, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("tls", () => require("tls"));

module.exports = mod;
}),
"[externals]/node:readline [external] (node:readline, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:readline", () => require("node:readline"));

module.exports = mod;
}),
"[externals]/node:querystring [external] (node:querystring, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:querystring", () => require("node:querystring"));

module.exports = mod;
}),
"[externals]/node:stream [external] (node:stream, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("node:stream", () => require("node:stream"));

module.exports = mod;
}),
"[externals]/crypto [external] (crypto, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("crypto", () => require("crypto"));

module.exports = mod;
}),
"[externals]/fs [external] (fs, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("fs", () => require("fs"));

module.exports = mod;
}),
"[externals]/path [external] (path, cjs)", ((__turbopack_context__, module, exports) => {

const mod = __turbopack_context__.x("path", () => require("path"));

module.exports = mod;
}),
"[project]/lib/k8s/client.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Kubernetes Client Configuration
 *
 * This module provides a configured Kubernetes client for interacting with
 * a Kubernetes cluster. It supports multiple authentication methods:
 * - Kubeconfig file (~/.kube/config)
 * - In-cluster configuration (for running inside a pod)
 * - Manual configuration
 */ __turbopack_context__.s([
    "checkConnection",
    ()=>checkConnection,
    "getAppsApi",
    ()=>getAppsApi,
    "getAutoscalingApi",
    ()=>getAutoscalingApi,
    "getBatchApi",
    ()=>getBatchApi,
    "getCoreApi",
    ()=>getCoreApi,
    "getEventsApi",
    ()=>getEventsApi,
    "getKubeConfig",
    ()=>getKubeConfig,
    "getNetworkingApi",
    ()=>getNetworkingApi,
    "initK8sClient",
    ()=>initK8sClient,
    "resetClient",
    ()=>resetClient
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/index.js [app-route] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$config$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/config.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@kubernetes/client-node/dist/gen/index.js [app-route] (ecmascript)");
;
let kc = null;
let k8sAppsApi = null;
let k8sCoreApi = null;
let k8sAutoscalingApi = null;
let k8sEventsApi = null;
let k8sNetworkingApi = null;
let k8sBatchApi = null;
function initK8sClient(contextName) {
    // Reset client to force reload (needed for AWS EKS exec auth)
    kc = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$config$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["KubeConfig"]();
    // Always use kubeconfig file for development (not in-cluster)
    // In-cluster config is only for when running inside Kubernetes pod
    try {
        // Load from kubeconfig file (~/.kube/config)
        kc.loadFromDefault();
        // Switch to specified context if provided
        if (contextName) {
            kc.setCurrentContext(contextName);
        }
        const cluster = kc.getCurrentCluster();
        const currentCtx = kc.getCurrentContext();
        // Validate cluster configuration
        if (!cluster?.server) {
            throw new Error(`Cluster server URL is not configured for context: ${contextName || currentCtx}`);
        }
    } catch (error) {
        console.error('[K8s] Failed to load Kubernetes configuration:', error);
        throw new Error('Failed to initialize Kubernetes client. Make sure kubeconfig is properly configured.');
    }
    // Initialize API clients (recreate on every call for fresh tokens)
    k8sAppsApi = kc.makeApiClient(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AppsV1Api"]);
    k8sCoreApi = kc.makeApiClient(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CoreV1Api"]);
    k8sAutoscalingApi = kc.makeApiClient(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["AutoscalingV2Api"]);
    k8sEventsApi = kc.makeApiClient(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["EventsV1Api"]);
    k8sNetworkingApi = kc.makeApiClient(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NetworkingV1Api"]);
    k8sBatchApi = kc.makeApiClient(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$kubernetes$2f$client$2d$node$2f$dist$2f$gen$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["BatchV1Api"]);
}
function getAppsApi(contextName) {
    // Always reinitialize for AWS EKS to refresh tokens
    initK8sClient(contextName);
    return k8sAppsApi;
}
function getCoreApi(contextName) {
    // Always reinitialize for AWS EKS to refresh tokens
    initK8sClient(contextName);
    return k8sCoreApi;
}
function getAutoscalingApi(contextName) {
    // Always reinitialize for AWS EKS to refresh tokens
    initK8sClient(contextName);
    return k8sAutoscalingApi;
}
function getEventsApi(contextName) {
    // Always reinitialize for AWS EKS to refresh tokens
    initK8sClient(contextName);
    return k8sEventsApi;
}
function getNetworkingApi(contextName) {
    // Always reinitialize for AWS EKS to refresh tokens
    initK8sClient(contextName);
    return k8sNetworkingApi;
}
function getBatchApi(contextName) {
    // Always reinitialize for AWS EKS to refresh tokens
    initK8sClient(contextName);
    return k8sBatchApi;
}
function getKubeConfig() {
    if (!kc) {
        initK8sClient();
    }
    return kc;
}
async function checkConnection() {
    try {
        const coreApi = getCoreApi();
        await coreApi.listNamespace();
        return true;
    } catch (error) {
        console.error('[K8s] Connection check failed:', error);
        return false;
    }
}
function resetClient() {
    kc = null;
    k8sAppsApi = null;
    k8sCoreApi = null;
    k8sAutoscalingApi = null;
    k8sEventsApi = null;
    k8sNetworkingApi = null;
    k8sBatchApi = null;
}
}),
"[project]/lib/k8s/api.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Kubernetes API Functions
 *
 * This module provides functions to interact with Kubernetes resources
 * using the official @kubernetes/client-node library.
 */ __turbopack_context__.s([
    "fetchConfigMap",
    ()=>fetchConfigMap,
    "fetchConfigMapYaml",
    ()=>fetchConfigMapYaml,
    "fetchConfigMaps",
    ()=>fetchConfigMaps,
    "fetchCronJob",
    ()=>fetchCronJob,
    "fetchCronJobs",
    ()=>fetchCronJobs,
    "fetchDaemonSet",
    ()=>fetchDaemonSet,
    "fetchDaemonSets",
    ()=>fetchDaemonSets,
    "fetchDeployment",
    ()=>fetchDeployment,
    "fetchDeploymentYaml",
    ()=>fetchDeploymentYaml,
    "fetchDeployments",
    ()=>fetchDeployments,
    "fetchEvents",
    ()=>fetchEvents,
    "fetchHPAs",
    ()=>fetchHPAs,
    "fetchIngress",
    ()=>fetchIngress,
    "fetchIngresses",
    ()=>fetchIngresses,
    "fetchJob",
    ()=>fetchJob,
    "fetchJobs",
    ()=>fetchJobs,
    "fetchLimitRange",
    ()=>fetchLimitRange,
    "fetchLimitRanges",
    ()=>fetchLimitRanges,
    "fetchNamespace",
    ()=>fetchNamespace,
    "fetchNamespaces",
    ()=>fetchNamespaces,
    "fetchNode",
    ()=>fetchNode,
    "fetchNodeEvents",
    ()=>fetchNodeEvents,
    "fetchNodePods",
    ()=>fetchNodePods,
    "fetchNodes",
    ()=>fetchNodes,
    "fetchPVCs",
    ()=>fetchPVCs,
    "fetchPVs",
    ()=>fetchPVs,
    "fetchPod",
    ()=>fetchPod,
    "fetchPodLogs",
    ()=>fetchPodLogs,
    "fetchPods",
    ()=>fetchPods,
    "fetchResourceEvents",
    ()=>fetchResourceEvents,
    "fetchResourceQuota",
    ()=>fetchResourceQuota,
    "fetchResourceQuotas",
    ()=>fetchResourceQuotas,
    "fetchResourcesWithLabels",
    ()=>fetchResourcesWithLabels,
    "fetchSecret",
    ()=>fetchSecret,
    "fetchSecretYaml",
    ()=>fetchSecretYaml,
    "fetchSecrets",
    ()=>fetchSecrets,
    "fetchService",
    ()=>fetchService,
    "fetchServices",
    ()=>fetchServices,
    "fetchStatefulSet",
    ()=>fetchStatefulSet,
    "fetchStatefulSets",
    ()=>fetchStatefulSets,
    "indexLabels",
    ()=>indexLabels,
    "searchByLabelSelector",
    ()=>searchByLabelSelector
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/k8s/client.ts [app-route] (ecmascript)");
;
/**
 * Helper: Calculate age from timestamp
 */ function calculateAge(timestamp) {
    if (!timestamp) return 'Unknown';
    const date = typeof timestamp === 'string' ? new Date(timestamp) : timestamp;
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
    if (diffDays === 0) {
        const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
        if (diffHours === 0) {
            const diffMins = Math.floor(diffMs / (1000 * 60));
            return `${diffMins}m`;
        }
        return `${diffHours}h`;
    }
    return `${diffDays}d`;
}
async function fetchDeployments(namespace, contextName) {
    const appsApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getAppsApi"])(contextName);
    const response = await appsApi.listNamespacedDeployment({
        namespace
    });
    return response.items.map((dep)=>{
        const readyReplicas = dep.status?.readyReplicas || 0;
        const availableReplicas = dep.status?.availableReplicas || 0;
        const unavailableReplicas = dep.status?.unavailableReplicas || 0;
        let status = 'Available';
        if (unavailableReplicas > 0) {
            status = 'Degraded';
        } else if (readyReplicas < (dep.spec?.replicas || 0)) {
            status = 'Progressing';
        }
        return {
            name: dep.metadata?.name || '',
            namespace: dep.metadata?.namespace || namespace,
            status,
            replicas: {
                desired: dep.spec?.replicas || 0,
                ready: readyReplicas,
                available: availableReplicas,
                unavailable: unavailableReplicas
            },
            strategy: dep.spec?.strategy?.type || 'RollingUpdate',
            age: calculateAge(dep.metadata?.creationTimestamp),
            labels: dep.metadata?.labels || {},
            selector: dep.spec?.selector?.matchLabels || {},
            configMaps: extractConfigMapNames(dep),
            secrets: extractSecretNames(dep)
        };
    });
}
async function fetchDeployment(name, namespace, contextName) {
    try {
        const appsApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getAppsApi"])(contextName);
        const response = await appsApi.readNamespacedDeployment({
            name,
            namespace
        });
        const dep = response;
        const readyReplicas = dep.status?.readyReplicas || 0;
        const availableReplicas = dep.status?.availableReplicas || 0;
        const unavailableReplicas = dep.status?.unavailableReplicas || 0;
        let status = 'Available';
        if (unavailableReplicas > 0) {
            status = 'Degraded';
        } else if (readyReplicas < (dep.spec?.replicas || 0)) {
            status = 'Progressing';
        }
        return {
            name: dep.metadata?.name || '',
            namespace: dep.metadata?.namespace || namespace,
            status,
            replicas: {
                desired: dep.spec?.replicas || 0,
                ready: readyReplicas,
                available: availableReplicas,
                unavailable: unavailableReplicas
            },
            strategy: dep.spec?.strategy?.type || 'RollingUpdate',
            age: calculateAge(dep.metadata?.creationTimestamp),
            labels: dep.metadata?.labels || {},
            selector: dep.spec?.selector?.matchLabels || {},
            configMaps: extractConfigMapNames(dep),
            secrets: extractSecretNames(dep)
        };
    } catch (error) {
        console.error(`[K8s] Failed to fetch deployment ${name}:`, error);
        return null;
    }
}
/**
 * Helper: Extract ConfigMap names from deployment
 */ function extractConfigMapNames(dep) {
    const configMaps = new Set();
    const containers = dep.spec?.template?.spec?.containers || [];
    containers.forEach((container)=>{
        // From envFrom
        container.envFrom?.forEach((envFrom)=>{
            if (envFrom.configMapRef?.name) {
                configMaps.add(envFrom.configMapRef.name);
            }
        });
        // From env
        container.env?.forEach((env)=>{
            if (env.valueFrom?.configMapKeyRef?.name) {
                configMaps.add(env.valueFrom.configMapKeyRef.name);
            }
        });
    });
    // From volumes
    dep.spec?.template?.spec?.volumes?.forEach((volume)=>{
        if (volume.configMap?.name) {
            configMaps.add(volume.configMap.name);
        }
    });
    return Array.from(configMaps);
}
/**
 * Helper: Extract Secret names from deployment
 */ function extractSecretNames(dep) {
    const secrets = new Set();
    const containers = dep.spec?.template?.spec?.containers || [];
    containers.forEach((container)=>{
        // From envFrom
        container.envFrom?.forEach((envFrom)=>{
            if (envFrom.secretRef?.name) {
                secrets.add(envFrom.secretRef.name);
            }
        });
        // From env
        container.env?.forEach((env)=>{
            if (env.valueFrom?.secretKeyRef?.name) {
                secrets.add(env.valueFrom.secretKeyRef.name);
            }
        });
    });
    // From volumes
    dep.spec?.template?.spec?.volumes?.forEach((volume)=>{
        if (volume.secret?.secretName) {
            secrets.add(volume.secret.secretName);
        }
    });
    // Image pull secrets
    dep.spec?.template?.spec?.imagePullSecrets?.forEach((secret)=>{
        if (secret.name) {
            secrets.add(secret.name);
        }
    });
    return Array.from(secrets);
}
async function fetchStatefulSets(namespace, contextName) {
    try {
        const appsApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getAppsApi"])(contextName);
        const response = await appsApi.listNamespacedStatefulSet({
            namespace
        });
        return response.items.map((sts)=>{
            const readyReplicas = sts.status?.readyReplicas || 0;
            const desired = sts.spec?.replicas || 0;
            let status = 'Available';
            if (readyReplicas < desired) {
                status = 'Progressing';
            }
            if (readyReplicas === 0 && desired > 0) {
                status = 'Degraded';
            }
            return {
                name: sts.metadata?.name || '',
                namespace: sts.metadata?.namespace || namespace,
                replicas: {
                    desired,
                    ready: readyReplicas,
                    current: sts.status?.currentReplicas || 0,
                    updated: sts.status?.updatedReplicas || 0
                },
                status,
                age: calculateAge(sts.metadata?.creationTimestamp),
                labels: sts.metadata?.labels || {},
                selector: sts.spec?.selector?.matchLabels || {},
                serviceName: sts.spec?.serviceName || '',
                updateStrategy: sts.spec?.updateStrategy?.type || 'RollingUpdate',
                podManagementPolicy: sts.spec?.podManagementPolicy || 'OrderedReady',
                persistentVolumeClaims: extractPVCNames(sts),
                configMaps: extractConfigMapNamesFromStatefulSet(sts),
                secrets: extractSecretNamesFromStatefulSet(sts)
            };
        });
    } catch (error) {
        console.error(`[K8s] Failed to fetch statefulsets in namespace ${namespace}:`, error);
        return [];
    }
}
async function fetchStatefulSet(name, namespace, contextName) {
    try {
        const appsApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getAppsApi"])(contextName);
        const response = await appsApi.readNamespacedStatefulSet({
            name,
            namespace
        });
        const sts = response;
        const readyReplicas = sts.status?.readyReplicas || 0;
        const desired = sts.spec?.replicas || 0;
        let status = 'Available';
        if (readyReplicas < desired) {
            status = 'Progressing';
        }
        if (readyReplicas === 0 && desired > 0) {
            status = 'Degraded';
        }
        return {
            name: sts.metadata?.name || name,
            namespace: sts.metadata?.namespace || namespace,
            replicas: {
                desired,
                ready: readyReplicas,
                current: sts.status?.currentReplicas || 0,
                updated: sts.status?.updatedReplicas || 0
            },
            status,
            age: calculateAge(sts.metadata?.creationTimestamp),
            labels: sts.metadata?.labels || {},
            selector: sts.spec?.selector?.matchLabels || {},
            serviceName: sts.spec?.serviceName || '',
            updateStrategy: sts.spec?.updateStrategy?.type || 'RollingUpdate',
            podManagementPolicy: sts.spec?.podManagementPolicy || 'OrderedReady',
            persistentVolumeClaims: extractPVCNames(sts),
            configMaps: extractConfigMapNamesFromStatefulSet(sts),
            secrets: extractSecretNamesFromStatefulSet(sts)
        };
    } catch (error) {
        console.error(`[K8s] Failed to fetch statefulset ${name}:`, error);
        return null;
    }
}
async function fetchDaemonSets(namespace, contextName) {
    try {
        const appsApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getAppsApi"])(contextName);
        const response = await appsApi.listNamespacedDaemonSet({
            namespace
        });
        return response.items.map((ds)=>({
                name: ds.metadata?.name || '',
                namespace: ds.metadata?.namespace || namespace,
                desired: ds.status?.desiredNumberScheduled || 0,
                current: ds.status?.currentNumberScheduled || 0,
                ready: ds.status?.numberReady || 0,
                upToDate: ds.status?.updatedNumberScheduled || 0,
                available: ds.status?.numberAvailable || 0,
                status: getDaemonSetStatus(ds.status),
                age: calculateAge(ds.metadata?.creationTimestamp),
                labels: ds.metadata?.labels || {},
                selector: ds.spec?.selector?.matchLabels || {},
                updateStrategy: ds.spec?.updateStrategy?.type || 'RollingUpdate',
                configMaps: extractConfigMapNamesFromDaemonSet(ds),
                secrets: extractSecretNamesFromDaemonSet(ds)
            }));
    } catch (error) {
        console.error(`[K8s] Failed to fetch daemonsets in namespace ${namespace}:`, error);
        return [];
    }
}
async function fetchDaemonSet(name, namespace, contextName) {
    try {
        const appsApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getAppsApi"])(contextName);
        const response = await appsApi.readNamespacedDaemonSet({
            name,
            namespace
        });
        const ds = response;
        return {
            name: ds.metadata?.name || name,
            namespace: ds.metadata?.namespace || namespace,
            desired: ds.status?.desiredNumberScheduled || 0,
            current: ds.status?.currentNumberScheduled || 0,
            ready: ds.status?.numberReady || 0,
            upToDate: ds.status?.updatedNumberScheduled || 0,
            available: ds.status?.numberAvailable || 0,
            status: getDaemonSetStatus(ds.status),
            age: calculateAge(ds.metadata?.creationTimestamp),
            labels: ds.metadata?.labels || {},
            selector: ds.spec?.selector?.matchLabels || {},
            updateStrategy: ds.spec?.updateStrategy?.type || 'RollingUpdate',
            configMaps: extractConfigMapNamesFromDaemonSet(ds),
            secrets: extractSecretNamesFromDaemonSet(ds)
        };
    } catch (error) {
        console.error(`[K8s] Failed to fetch daemonset ${name}:`, error);
        return null;
    }
}
/**
 * Helper: Extract PVC names from StatefulSet
 */ function extractPVCNames(sts) {
    const pvcTemplates = sts.spec?.volumeClaimTemplates || [];
    return pvcTemplates.map((pvc)=>pvc.metadata?.name || '').filter(Boolean);
}
/**
 * Helper: Extract ConfigMap names from StatefulSet
 */ function extractConfigMapNamesFromStatefulSet(sts) {
    const configMaps = new Set();
    const containers = sts.spec?.template?.spec?.containers || [];
    containers.forEach((container)=>{
        container.envFrom?.forEach((envFrom)=>{
            if (envFrom.configMapRef?.name) {
                configMaps.add(envFrom.configMapRef.name);
            }
        });
        container.env?.forEach((env)=>{
            if (env.valueFrom?.configMapKeyRef?.name) {
                configMaps.add(env.valueFrom.configMapKeyRef.name);
            }
        });
    });
    sts.spec?.template?.spec?.volumes?.forEach((volume)=>{
        if (volume.configMap?.name) {
            configMaps.add(volume.configMap.name);
        }
    });
    return Array.from(configMaps);
}
/**
 * Helper: Extract Secret names from StatefulSet
 */ function extractSecretNamesFromStatefulSet(sts) {
    const secrets = new Set();
    const containers = sts.spec?.template?.spec?.containers || [];
    containers.forEach((container)=>{
        container.envFrom?.forEach((envFrom)=>{
            if (envFrom.secretRef?.name) {
                secrets.add(envFrom.secretRef.name);
            }
        });
        container.env?.forEach((env)=>{
            if (env.valueFrom?.secretKeyRef?.name) {
                secrets.add(env.valueFrom.secretKeyRef.name);
            }
        });
    });
    sts.spec?.template?.spec?.volumes?.forEach((volume)=>{
        if (volume.secret?.secretName) {
            secrets.add(volume.secret.secretName);
        }
    });
    sts.spec?.template?.spec?.imagePullSecrets?.forEach((secret)=>{
        if (secret.name) {
            secrets.add(secret.name);
        }
    });
    return Array.from(secrets);
}
/**
 * Helper: Extract ConfigMap names from DaemonSet
 */ function extractConfigMapNamesFromDaemonSet(ds) {
    const configMaps = new Set();
    const containers = ds.spec?.template?.spec?.containers || [];
    containers.forEach((container)=>{
        container.envFrom?.forEach((envFrom)=>{
            if (envFrom.configMapRef?.name) {
                configMaps.add(envFrom.configMapRef.name);
            }
        });
        container.env?.forEach((env)=>{
            if (env.valueFrom?.configMapKeyRef?.name) {
                configMaps.add(env.valueFrom.configMapKeyRef.name);
            }
        });
    });
    ds.spec?.template?.spec?.volumes?.forEach((volume)=>{
        if (volume.configMap?.name) {
            configMaps.add(volume.configMap.name);
        }
    });
    return Array.from(configMaps);
}
/**
 * Helper: Extract Secret names from DaemonSet
 */ function extractSecretNamesFromDaemonSet(ds) {
    const secrets = new Set();
    const containers = ds.spec?.template?.spec?.containers || [];
    containers.forEach((container)=>{
        container.envFrom?.forEach((envFrom)=>{
            if (envFrom.secretRef?.name) {
                secrets.add(envFrom.secretRef.name);
            }
        });
        container.env?.forEach((env)=>{
            if (env.valueFrom?.secretKeyRef?.name) {
                secrets.add(env.valueFrom.secretKeyRef.name);
            }
        });
    });
    ds.spec?.template?.spec?.volumes?.forEach((volume)=>{
        if (volume.secret?.secretName) {
            secrets.add(volume.secret.secretName);
        }
    });
    ds.spec?.template?.spec?.imagePullSecrets?.forEach((secret)=>{
        if (secret.name) {
            secrets.add(secret.name);
        }
    });
    return Array.from(secrets);
}
/**
 * Helper: Get DaemonSet status
 */ function getDaemonSetStatus(status) {
    if (!status) return 'Unknown';
    const desired = status.desiredNumberScheduled || 0;
    const ready = status.numberReady || 0;
    const available = status.numberAvailable || 0;
    if (ready === 0) return 'Not Ready';
    if (ready < desired) return 'Degraded';
    if (available === desired && ready === desired) return 'Healthy';
    return 'Unknown';
}
/**
 * Helper: Extract ConfigMap names from pod
 */ function extractConfigMapNamesFromPod(pod) {
    const configMaps = new Set();
    const containers = pod.spec?.containers || [];
    containers.forEach((container)=>{
        // From envFrom
        container.envFrom?.forEach((envFrom)=>{
            if (envFrom.configMapRef?.name) {
                configMaps.add(envFrom.configMapRef.name);
            }
        });
        // From env
        container.env?.forEach((env)=>{
            if (env.valueFrom?.configMapKeyRef?.name) {
                configMaps.add(env.valueFrom.configMapKeyRef.name);
            }
        });
    });
    // From volumes
    pod.spec?.volumes?.forEach((volume)=>{
        if (volume.configMap?.name) {
            configMaps.add(volume.configMap.name);
        }
    });
    return Array.from(configMaps);
}
/**
 * Helper: Extract Secret names from pod
 */ function extractSecretNamesFromPod(pod) {
    const secrets = new Set();
    const containers = pod.spec?.containers || [];
    containers.forEach((container)=>{
        // From envFrom
        container.envFrom?.forEach((envFrom)=>{
            if (envFrom.secretRef?.name) {
                secrets.add(envFrom.secretRef.name);
            }
        });
        // From env
        container.env?.forEach((env)=>{
            if (env.valueFrom?.secretKeyRef?.name) {
                secrets.add(env.valueFrom.secretKeyRef.name);
            }
        });
    });
    // From volumes
    pod.spec?.volumes?.forEach((volume)=>{
        if (volume.secret?.secretName) {
            secrets.add(volume.secret.secretName);
        }
    });
    // Image pull secrets
    pod.spec?.imagePullSecrets?.forEach((secret)=>{
        if (secret.name) {
            secrets.add(secret.name);
        }
    });
    return Array.from(secrets);
}
async function fetchPods(namespace, contextName, labelSelector) {
    const coreApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCoreApi"])(contextName);
    const response = await coreApi.listNamespacedPod({
        namespace,
        labelSelector
    });
    return response.items.map((pod)=>{
        const containerStatuses = pod.status?.containerStatuses || [];
        const totalRestarts = containerStatuses.reduce((sum, cs)=>sum + (cs.restartCount || 0), 0);
        return {
            name: pod.metadata?.name || '',
            namespace: pod.metadata?.namespace || namespace,
            status: pod.status?.phase || 'Unknown',
            nodeName: pod.spec?.nodeName || 'Unknown',
            ip: pod.status?.podIP || 'Unknown',
            restartCount: totalRestarts,
            age: calculateAge(pod.metadata?.creationTimestamp),
            labels: pod.metadata?.labels || {},
            containers: containerStatuses.map((cs)=>({
                    name: cs.name,
                    image: cs.image || '',
                    ready: cs.ready || false,
                    restartCount: cs.restartCount || 0
                })),
            configMaps: extractConfigMapNamesFromPod(pod),
            secrets: extractSecretNamesFromPod(pod)
        };
    });
}
/**
 * Helper: Parse probe configuration
 */ function parseProbe(probe) {
    if (!probe) return undefined;
    const result = {
        initialDelaySeconds: probe.initialDelaySeconds,
        periodSeconds: probe.periodSeconds,
        timeoutSeconds: probe.timeoutSeconds,
        successThreshold: probe.successThreshold,
        failureThreshold: probe.failureThreshold
    };
    if (probe.httpGet) {
        result.type = 'httpGet';
        result.httpGet = {
            path: probe.httpGet.path || '/',
            port: probe.httpGet.port,
            scheme: probe.httpGet.scheme || 'HTTP'
        };
    } else if (probe.tcpSocket) {
        result.type = 'tcpSocket';
        result.tcpSocket = {
            port: probe.tcpSocket.port
        };
    } else if (probe.exec) {
        result.type = 'exec';
        result.exec = {
            command: probe.exec.command || []
        };
    } else if (probe.grpc) {
        result.type = 'grpc';
    }
    return result;
}
async function fetchPod(name, namespace, contextName) {
    try {
        const coreApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCoreApi"])(contextName);
        const response = await coreApi.readNamespacedPod({
            name,
            namespace
        });
        const pod = response;
        const containerStatuses = pod.status?.containerStatuses || [];
        const containerSpecs = pod.spec?.containers || [];
        const totalRestarts = containerStatuses.reduce((sum, cs)=>sum + (cs.restartCount || 0), 0);
        return {
            name: pod.metadata?.name || '',
            namespace: pod.metadata?.namespace || namespace,
            status: pod.status?.phase || 'Unknown',
            nodeName: pod.spec?.nodeName || 'Unknown',
            ip: pod.status?.podIP || 'Unknown',
            restartCount: totalRestarts,
            age: calculateAge(pod.metadata?.creationTimestamp),
            labels: pod.metadata?.labels || {},
            containers: containerSpecs.map((spec)=>({
                    name: spec.name,
                    image: spec.image || '',
                    ready: containerStatuses.find((cs)=>cs.name === spec.name)?.ready || false,
                    restartCount: containerStatuses.find((cs)=>cs.name === spec.name)?.restartCount || 0,
                    livenessProbe: parseProbe(spec.livenessProbe),
                    readinessProbe: parseProbe(spec.readinessProbe),
                    startupProbe: parseProbe(spec.startupProbe)
                })),
            containerStatuses: containerStatuses.map((cs)=>({
                    name: cs.name,
                    ready: cs.ready || false,
                    restartCount: cs.restartCount || 0,
                    state: {
                        waiting: cs.state?.waiting ? {
                            reason: cs.state.waiting.reason || '',
                            message: cs.state.waiting.message
                        } : undefined,
                        running: cs.state?.running ? {
                            startedAt: cs.state.running.startedAt?.toISOString() || ''
                        } : undefined,
                        terminated: cs.state?.terminated ? {
                            exitCode: cs.state.terminated.exitCode || 0,
                            reason: cs.state.terminated.reason || '',
                            message: cs.state.terminated.message,
                            startedAt: cs.state.terminated.startedAt?.toISOString() || '',
                            finishedAt: cs.state.terminated.finishedAt?.toISOString() || ''
                        } : undefined
                    },
                    lastState: cs.lastState ? {
                        waiting: cs.lastState.waiting ? {
                            reason: cs.lastState.waiting.reason || '',
                            message: cs.lastState.waiting.message
                        } : undefined,
                        running: cs.lastState.running ? {
                            startedAt: cs.lastState.running.startedAt?.toISOString() || ''
                        } : undefined,
                        terminated: cs.lastState.terminated ? {
                            exitCode: cs.lastState.terminated.exitCode || 0,
                            reason: cs.lastState.terminated.reason || '',
                            message: cs.lastState.terminated.message,
                            startedAt: cs.lastState.terminated.startedAt?.toISOString() || '',
                            finishedAt: cs.lastState.terminated.finishedAt?.toISOString() || ''
                        } : undefined
                    } : undefined
                })),
            configMaps: extractConfigMapNamesFromPod(pod),
            secrets: extractSecretNamesFromPod(pod)
        };
    } catch (error) {
        console.error(`[K8s] Failed to fetch pod ${name}:`, error);
        return null;
    }
}
async function fetchPodLogs(name, namespace, contextName, container, tail = 100, previous = false) {
    try {
        const coreApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCoreApi"])(contextName);
        const response = await coreApi.readNamespacedPodLog({
            name,
            namespace,
            container,
            tailLines: tail,
            previous,
            timestamps: true
        });
        return response;
    } catch (error) {
        console.error(`[K8s] Failed to fetch logs for pod ${name}:`, error);
        throw error;
    }
}
async function fetchNodes(contextName) {
    const coreApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCoreApi"])(contextName);
    const response = await coreApi.listNode({});
    return response.items.map((node)=>{
        const conditions = node.status?.conditions || [];
        const readyCondition = conditions.find((c)=>c.type === 'Ready');
        let status = 'Unknown';
        if (readyCondition) {
            status = readyCondition.status === 'True' ? 'Ready' : 'NotReady';
        }
        const roles = node.metadata?.labels ? Object.keys(node.metadata.labels).filter((label)=>label.startsWith('node-role.kubernetes.io/')).map((label)=>label.replace('node-role.kubernetes.io/', '')) : [];
        return {
            name: node.metadata?.name || '',
            status,
            roles: roles.length > 0 ? roles : [
                '<none>'
            ],
            version: node.status?.nodeInfo?.kubeletVersion || 'Unknown',
            capacity: {
                cpu: node.status?.capacity?.cpu || '0',
                memory: node.status?.capacity?.memory || '0',
                pods: node.status?.capacity?.pods || '0'
            },
            allocatable: {
                cpu: node.status?.allocatable?.cpu || '0',
                memory: node.status?.allocatable?.memory || '0',
                pods: node.status?.allocatable?.pods || '0'
            },
            age: calculateAge(node.metadata?.creationTimestamp),
            labels: node.metadata?.labels || {},
            conditions: conditions.map((c)=>({
                    type: c.type || '',
                    status: c.status || '',
                    reason: c.reason || '',
                    message: c.message || '',
                    lastTransitionTime: c.lastTransitionTime?.toString() || ''
                }))
        };
    });
}
async function fetchNode(name, contextName) {
    try {
        const coreApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCoreApi"])(contextName);
        const response = await coreApi.readNode({
            name
        });
        const node = response;
        const conditions = node.status?.conditions || [];
        const readyCondition = conditions.find((c)=>c.type === 'Ready');
        let status = 'Unknown';
        if (readyCondition) {
            status = readyCondition.status === 'True' ? 'Ready' : 'NotReady';
        }
        const roles = node.metadata?.labels ? Object.keys(node.metadata.labels).filter((label)=>label.startsWith('node-role.kubernetes.io/')).map((label)=>label.replace('node-role.kubernetes.io/', '')) : [];
        return {
            name: node.metadata?.name || '',
            status,
            roles: roles.length > 0 ? roles : [
                '<none>'
            ],
            version: node.status?.nodeInfo?.kubeletVersion || 'Unknown',
            capacity: {
                cpu: node.status?.capacity?.cpu || '0',
                memory: node.status?.capacity?.memory || '0',
                pods: node.status?.capacity?.pods || '0'
            },
            allocatable: {
                cpu: node.status?.allocatable?.cpu || '0',
                memory: node.status?.allocatable?.memory || '0',
                pods: node.status?.allocatable?.pods || '0'
            },
            age: calculateAge(node.metadata?.creationTimestamp),
            labels: node.metadata?.labels || {},
            conditions: conditions.map((c)=>({
                    type: c.type || '',
                    status: c.status || '',
                    reason: c.reason || '',
                    message: c.message || '',
                    lastTransitionTime: c.lastTransitionTime?.toString() || ''
                }))
        };
    } catch (error) {
        console.error(`[K8s] Failed to fetch node ${name}:`, error);
        return null;
    }
}
async function fetchNodeEvents(nodeName) {
    return fetchResourceEvents('Node', nodeName, '');
}
async function fetchNodePods(nodeName, namespace, contextName) {
    try {
        const coreApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCoreApi"])(contextName);
        // If no namespace provided, we can't list pods (no cluster-level permission)
        if (!namespace) {
            console.warn('[K8s] Cannot fetch node pods without namespace (no cluster-level permission)');
            return [];
        }
        // List pods in the specified namespace only
        const response = await coreApi.listNamespacedPod({
            namespace,
            fieldSelector: `spec.nodeName=${nodeName}`
        });
        return response.items.map((pod)=>{
            const containerStatuses = pod.status?.containerStatuses || [];
            const totalRestarts = containerStatuses.reduce((sum, cs)=>sum + (cs.restartCount || 0), 0);
            return {
                name: pod.metadata?.name || '',
                namespace: pod.metadata?.namespace || '',
                status: pod.status?.phase || 'Unknown',
                nodeName: pod.spec?.nodeName || 'Unknown',
                ip: pod.status?.podIP || 'Unknown',
                restartCount: totalRestarts,
                age: calculateAge(pod.metadata?.creationTimestamp),
                labels: pod.metadata?.labels || {},
                containers: containerStatuses.map((cs)=>({
                        name: cs.name,
                        image: cs.image || '',
                        ready: cs.ready || false,
                        restartCount: cs.restartCount || 0
                    })),
                configMaps: extractConfigMapNamesFromPod(pod),
                secrets: extractSecretNamesFromPod(pod)
            };
        });
    } catch (error) {
        // Silently handle 403 (permission denied) - just return empty array
        if (error?.code !== 403) {
            console.error(`[K8s] Failed to fetch pods for node ${nodeName}:`, error);
        }
        return [];
    }
}
async function fetchConfigMaps(namespace, contextName) {
    const coreApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCoreApi"])(contextName);
    const response = await coreApi.listNamespacedConfigMap({
        namespace
    });
    return response.items.map((cm)=>({
            name: cm.metadata?.name || '',
            namespace: cm.metadata?.namespace || namespace,
            data: cm.data || {},
            age: calculateAge(cm.metadata?.creationTimestamp),
            labels: cm.metadata?.labels || {}
        }));
}
async function fetchConfigMap(name, namespace, contextName) {
    try {
        const coreApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCoreApi"])(contextName);
        const response = await coreApi.readNamespacedConfigMap({
            name,
            namespace
        });
        const cm = response;
        return {
            name: cm.metadata?.name || '',
            namespace: cm.metadata?.namespace || namespace,
            data: cm.data || {},
            age: calculateAge(cm.metadata?.creationTimestamp),
            labels: cm.metadata?.labels || {}
        };
    } catch (error) {
        console.error(`[K8s] Failed to fetch configmap ${name}:`, error);
        return null;
    }
}
async function fetchSecrets(namespace, contextName) {
    const coreApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCoreApi"])(contextName);
    const response = await coreApi.listNamespacedSecret({
        namespace
    });
    return response.items.map((secret)=>{
        // For list view, we don't include the actual data (only for detail view)
        const data = {};
        if (secret.data) {
            for (const key of Object.keys(secret.data)){
                data[key] = ''; // Empty placeholder for list view
            }
        }
        return {
            name: secret.metadata?.name || '',
            namespace: secret.metadata?.namespace || namespace,
            type: secret.type || 'Opaque',
            keys: Object.keys(secret.data || {}),
            data,
            age: calculateAge(secret.metadata?.creationTimestamp),
            labels: secret.metadata?.labels || {}
        };
    });
}
async function fetchSecret(name, namespace, contextName) {
    try {
        const coreApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCoreApi"])(contextName);
        const response = await coreApi.readNamespacedSecret({
            name,
            namespace
        });
        const secret = response;
        // Convert data to Record<string, string> (values are base64 encoded)
        const data = {};
        if (secret.data) {
            for (const [key, value] of Object.entries(secret.data)){
                data[key] = value;
            }
        }
        return {
            name: secret.metadata?.name || '',
            namespace: secret.metadata?.namespace || namespace,
            type: secret.type || 'Opaque',
            keys: Object.keys(secret.data || {}),
            data,
            age: calculateAge(secret.metadata?.creationTimestamp),
            labels: secret.metadata?.labels || {}
        };
    } catch (error) {
        console.error(`[K8s] Failed to fetch secret ${name}:`, error);
        return null;
    }
}
async function fetchHPAs(namespace, contextName) {
    const autoscalingApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getAutoscalingApi"])(contextName);
    const response = await autoscalingApi.listNamespacedHorizontalPodAutoscaler({
        namespace
    });
    return response.items.map((hpa)=>{
        const currentReplicas = hpa.status?.currentReplicas || 0;
        const desiredReplicas = hpa.status?.desiredReplicas || 0;
        const minReplicas = hpa.spec?.minReplicas || 1;
        const maxReplicas = hpa.spec?.maxReplicas || 1;
        // Extract CPU metrics
        const cpuMetric = hpa.status?.currentMetrics?.find((m)=>m.type === 'Resource' && m.resource?.name === 'cpu');
        const cpuCurrent = cpuMetric?.resource?.current?.averageUtilization || 0;
        const cpuTargetMetric = hpa.spec?.metrics?.find((m)=>m.type === 'Resource' && m.resource?.name === 'cpu');
        const cpuTarget = cpuTargetMetric?.resource?.target?.averageUtilization || 0;
        return {
            name: hpa.metadata?.name || '',
            namespace: hpa.metadata?.namespace || namespace,
            targetRef: {
                kind: hpa.spec?.scaleTargetRef?.kind || '',
                name: hpa.spec?.scaleTargetRef?.name || ''
            },
            minReplicas,
            maxReplicas,
            currentReplicas,
            desiredReplicas,
            metrics: [
                {
                    type: 'Resource',
                    resource: {
                        name: 'cpu',
                        target: {
                            type: 'Utilization',
                            averageUtilization: cpuTarget
                        },
                        current: {
                            averageUtilization: cpuCurrent
                        }
                    }
                }
            ],
            age: calculateAge(hpa.metadata?.creationTimestamp),
            labels: hpa.metadata?.labels || {}
        };
    });
}
async function fetchPVs(contextName) {
    const coreApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCoreApi"])(contextName);
    const response = await coreApi.listPersistentVolume({});
    return response.items.map((pv)=>({
            name: pv.metadata?.name || '',
            capacity: pv.spec?.capacity?.storage || '0',
            accessModes: pv.spec?.accessModes || [],
            reclaimPolicy: pv.spec?.persistentVolumeReclaimPolicy || 'Retain',
            status: pv.status?.phase || 'Unknown',
            claim: pv.spec?.claimRef ? `${pv.spec.claimRef.namespace}/${pv.spec.claimRef.name}` : '',
            storageClass: pv.spec?.storageClassName || '',
            age: calculateAge(pv.metadata?.creationTimestamp)
        }));
}
async function fetchPVCs(namespace, contextName) {
    const coreApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCoreApi"])(contextName);
    const response = await coreApi.listNamespacedPersistentVolumeClaim({
        namespace
    });
    return response.items.map((pvc)=>({
            name: pvc.metadata?.name || '',
            namespace: pvc.metadata?.namespace || namespace,
            status: pvc.status?.phase || 'Unknown',
            volume: pvc.spec?.volumeName || '',
            capacity: pvc.status?.capacity?.storage || '0',
            accessModes: pvc.spec?.accessModes || [],
            storageClass: pvc.spec?.storageClassName || '',
            age: calculateAge(pvc.metadata?.creationTimestamp),
            labels: pvc.metadata?.labels || {}
        }));
}
async function fetchEvents(namespace, contextName, timeRangeHours = 24) {
    const coreApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCoreApi"])(contextName);
    const response = namespace ? await coreApi.listNamespacedEvent({
        namespace
    }) : await coreApi.listEventForAllNamespaces({});
    // Calculate cutoff time
    const cutoffTime = new Date();
    cutoffTime.setHours(cutoffTime.getHours() - timeRangeHours);
    // Filter events by time range and map to our Event type
    return response.items.filter((event)=>{
        const lastTimestamp = event.lastTimestamp || event.eventTime;
        if (!lastTimestamp) return false;
        const eventTime = new Date(lastTimestamp.toString());
        return eventTime >= cutoffTime;
    }).map((event)=>({
            type: event.type || 'Normal',
            reason: event.reason || '',
            message: event.message || '',
            kind: event.involvedObject?.kind || '',
            name: event.involvedObject?.name || '',
            namespace: event.involvedObject?.namespace || '',
            count: event.count || 1,
            firstTimestamp: event.firstTimestamp?.toString() || '',
            lastTimestamp: event.lastTimestamp?.toString() || ''
        })).sort((a, b)=>{
        // Sort by lastTimestamp descending (most recent first)
        const aTime = new Date(a.lastTimestamp).getTime();
        const bTime = new Date(b.lastTimestamp).getTime();
        return bTime - aTime;
    });
}
async function fetchResourceEvents(kind, name, namespace, contextName) {
    try {
        const coreApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCoreApi"])(contextName);
        const fieldSelector = `involvedObject.kind=${kind},involvedObject.name=${name}`;
        const response = await coreApi.listNamespacedEvent({
            namespace,
            fieldSelector
        });
        return response.items.map((event)=>({
                type: event.type || 'Normal',
                reason: event.reason || '',
                message: event.message || '',
                kind: event.involvedObject?.kind || '',
                name: event.involvedObject?.name || '',
                namespace: event.involvedObject?.namespace || '',
                count: event.count || 1,
                firstTimestamp: event.firstTimestamp?.toString() || '',
                lastTimestamp: event.lastTimestamp?.toString() || ''
            }));
    } catch (error) {
        // Silently handle 403 (permission denied) - just return empty array
        if (error?.code !== 403) {
            console.error(`[API] Failed to fetch Node events:`, error);
        }
        return [];
    }
}
async function fetchDeploymentYaml(name, namespace, contextName) {
    try {
        const appsApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getAppsApi"])(contextName);
        const response = await appsApi.readNamespacedDeployment({
            name,
            namespace
        });
        // Convert to YAML using js-yaml
        // eslint-disable-next-line @typescript-eslint/no-require-imports
        const yaml = __turbopack_context__.r("[project]/node_modules/js-yaml/index.js [app-route] (ecmascript)");
        const yamlString = yaml.dump(response, {
            noRefs: true,
            sortKeys: true
        });
        return yamlString;
    } catch (error) {
        console.error('[API] Failed to fetch deployment YAML:', error);
        return null;
    }
}
async function fetchConfigMapYaml(name, namespace, contextName) {
    try {
        const coreApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCoreApi"])(contextName);
        const response = await coreApi.readNamespacedConfigMap({
            name,
            namespace
        });
        // eslint-disable-next-line @typescript-eslint/no-require-imports
        const yaml = __turbopack_context__.r("[project]/node_modules/js-yaml/index.js [app-route] (ecmascript)");
        const yamlString = yaml.dump(response, {
            noRefs: true,
            sortKeys: true
        });
        return yamlString;
    } catch (error) {
        console.error('[API] Failed to fetch configmap YAML:', error);
        return null;
    }
}
async function fetchSecretYaml(name, namespace, contextName) {
    try {
        const coreApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCoreApi"])(contextName);
        const response = await coreApi.readNamespacedSecret({
            name,
            namespace
        });
        // eslint-disable-next-line @typescript-eslint/no-require-imports
        const yaml = __turbopack_context__.r("[project]/node_modules/js-yaml/index.js [app-route] (ecmascript)");
        const yamlString = yaml.dump(response, {
            noRefs: true,
            sortKeys: true
        });
        return yamlString;
    } catch (error) {
        console.error('[API] Failed to fetch secret YAML:', error);
        return null;
    }
}
async function fetchServices(namespace, contextName) {
    const coreApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCoreApi"])(contextName);
    const response = await coreApi.listNamespacedService({
        namespace
    });
    return response.items.map((svc)=>{
        const ports = (svc.spec?.ports || []).map((port)=>({
                name: port.name,
                protocol: port.protocol || 'TCP',
                port: port.port || 0,
                targetPort: port.targetPort || 0,
                nodePort: port.nodePort
            }));
        return {
            name: svc.metadata?.name || '',
            namespace: svc.metadata?.namespace || namespace,
            type: svc.spec?.type || 'ClusterIP',
            clusterIP: svc.spec?.clusterIP || '',
            externalIPs: svc.spec?.externalIPs,
            ports,
            selector: svc.spec?.selector || {},
            age: calculateAge(svc.metadata?.creationTimestamp),
            labels: svc.metadata?.labels || {}
        };
    });
}
async function fetchService(name, namespace, contextName) {
    try {
        const coreApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCoreApi"])(contextName);
        const response = await coreApi.readNamespacedService({
            name,
            namespace
        });
        const svc = response;
        const ports = (svc.spec?.ports || []).map((port)=>({
                name: port.name,
                protocol: port.protocol || 'TCP',
                port: port.port || 0,
                targetPort: port.targetPort || 0,
                nodePort: port.nodePort
            }));
        return {
            name: svc.metadata?.name || '',
            namespace: svc.metadata?.namespace || namespace,
            type: svc.spec?.type || 'ClusterIP',
            clusterIP: svc.spec?.clusterIP || '',
            externalIPs: svc.spec?.externalIPs,
            ports,
            selector: svc.spec?.selector || {},
            age: calculateAge(svc.metadata?.creationTimestamp),
            labels: svc.metadata?.labels || {}
        };
    } catch (error) {
        console.error(`[K8s] Failed to fetch service ${name}:`, error);
        return null;
    }
}
async function fetchIngresses(namespace, contextName) {
    const networkingApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getNetworkingApi"])(contextName);
    const response = await networkingApi.listNamespacedIngress({
        namespace
    });
    return response.items.map((ing)=>{
        // Extract hosts from rules
        const hosts = [];
        const rules = (ing.spec?.rules || []).map((rule)=>{
            if (rule.host) {
                hosts.push(rule.host);
            }
            const paths = (rule.http?.paths || []).map((path)=>({
                    path: path.path || '/',
                    pathType: path.pathType || 'Prefix',
                    backend: {
                        service: {
                            name: path.backend?.service?.name || '',
                            port: {
                                number: path.backend?.service?.port?.number,
                                name: path.backend?.service?.port?.name
                            }
                        }
                    }
                }));
            return {
                host: rule.host,
                paths
            };
        });
        // Extract TLS configuration
        const tls = ing.spec?.tls?.map((tlsConfig)=>({
                hosts: tlsConfig.hosts || [],
                secretName: tlsConfig.secretName
            }));
        return {
            name: ing.metadata?.name || '',
            namespace: ing.metadata?.namespace || namespace,
            className: ing.spec?.ingressClassName,
            hosts,
            rules,
            tls,
            age: calculateAge(ing.metadata?.creationTimestamp),
            labels: ing.metadata?.labels || {}
        };
    });
}
async function fetchIngress(name, namespace, contextName) {
    try {
        const networkingApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getNetworkingApi"])(contextName);
        const response = await networkingApi.readNamespacedIngress({
            name,
            namespace
        });
        const ing = response;
        // Extract hosts from rules
        const hosts = [];
        const rules = (ing.spec?.rules || []).map((rule)=>{
            if (rule.host) {
                hosts.push(rule.host);
            }
            const paths = (rule.http?.paths || []).map((path)=>({
                    path: path.path || '/',
                    pathType: path.pathType || 'Prefix',
                    backend: {
                        service: {
                            name: path.backend?.service?.name || '',
                            port: {
                                number: path.backend?.service?.port?.number,
                                name: path.backend?.service?.port?.name
                            }
                        }
                    }
                }));
            return {
                host: rule.host,
                paths
            };
        });
        // Extract TLS configuration
        const tls = ing.spec?.tls?.map((tlsConfig)=>({
                hosts: tlsConfig.hosts || [],
                secretName: tlsConfig.secretName
            }));
        return {
            name: ing.metadata?.name || '',
            namespace: ing.metadata?.namespace || namespace,
            className: ing.spec?.ingressClassName,
            hosts,
            rules,
            tls,
            age: calculateAge(ing.metadata?.creationTimestamp),
            labels: ing.metadata?.labels || {}
        };
    } catch (error) {
        console.error(`[K8s] Failed to fetch ingress ${name}:`, error);
        return null;
    }
}
/**
 * Jobs API
 */ function calculateDuration(startTime, completionTime) {
    if (!startTime) return undefined;
    const start = new Date(startTime);
    const end = completionTime ? new Date(completionTime) : new Date();
    const diffMs = end.getTime() - start.getTime();
    const seconds = Math.floor(diffMs / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    if (hours > 0) return `${hours}h ${minutes % 60}m`;
    if (minutes > 0) return `${minutes}m ${seconds % 60}s`;
    return `${seconds}s`;
}
function determineJobStatus(job) {
    const conditions = job.status?.conditions || [];
    const succeeded = job.status?.succeeded || 0;
    const failed = job.status?.failed || 0;
    const active = job.status?.active || 0;
    // Check conditions
    const completeCondition = conditions.find((c)=>c.type === 'Complete' && c.status === 'True');
    const failedCondition = conditions.find((c)=>c.type === 'Failed' && c.status === 'True');
    if (completeCondition) return 'Complete';
    if (failedCondition) return 'Failed';
    if (active > 0) return 'Running';
    if (succeeded === 0 && failed === 0 && active === 0) return 'Pending';
    return 'Unknown';
}
async function fetchJobs(namespace, contextName) {
    const batchApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getBatchApi"])(contextName);
    const response = await batchApi.listNamespacedJob({
        namespace
    });
    return response.items.map((job)=>{
        const completions = job.spec?.completions || 1;
        const succeeded = job.status?.succeeded || 0;
        const failed = job.status?.failed || 0;
        const active = job.status?.active || 0;
        const status = determineJobStatus(job);
        const conditions = (job.status?.conditions || []).map((c)=>({
                type: c.type || '',
                status: c.status || '',
                lastProbeTime: c.lastProbeTime?.toISOString(),
                lastTransitionTime: c.lastTransitionTime?.toISOString(),
                reason: c.reason,
                message: c.message
            }));
        return {
            name: job.metadata?.name || '',
            namespace: job.metadata?.namespace || namespace,
            status,
            completions,
            succeeded,
            failed,
            active,
            startTime: job.status?.startTime?.toISOString(),
            completionTime: job.status?.completionTime?.toISOString(),
            duration: calculateDuration(job.status?.startTime?.toISOString(), job.status?.completionTime?.toISOString()),
            age: calculateAge(job.metadata?.creationTimestamp),
            labels: job.metadata?.labels || {},
            conditions
        };
    });
}
async function fetchJob(name, namespace, contextName) {
    try {
        const batchApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getBatchApi"])(contextName);
        const response = await batchApi.readNamespacedJob({
            name,
            namespace
        });
        const job = response;
        const completions = job.spec?.completions || 1;
        const succeeded = job.status?.succeeded || 0;
        const failed = job.status?.failed || 0;
        const active = job.status?.active || 0;
        const status = determineJobStatus(job);
        const conditions = (job.status?.conditions || []).map((c)=>({
                type: c.type || '',
                status: c.status || '',
                lastProbeTime: c.lastProbeTime?.toISOString(),
                lastTransitionTime: c.lastTransitionTime?.toISOString(),
                reason: c.reason,
                message: c.message
            }));
        return {
            name: job.metadata?.name || '',
            namespace: job.metadata?.namespace || namespace,
            status,
            completions,
            succeeded,
            failed,
            active,
            startTime: job.status?.startTime?.toISOString(),
            completionTime: job.status?.completionTime?.toISOString(),
            duration: calculateDuration(job.status?.startTime?.toISOString(), job.status?.completionTime?.toISOString()),
            age: calculateAge(job.metadata?.creationTimestamp),
            labels: job.metadata?.labels || {},
            conditions
        };
    } catch (error) {
        console.error(`[K8s] Failed to fetch job ${name}:`, error);
        return null;
    }
}
async function fetchCronJobs(namespace, contextName) {
    const batchApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getBatchApi"])(contextName);
    const response = await batchApi.listNamespacedCronJob({
        namespace
    });
    return response.items.map((cronJob)=>{
        return {
            name: cronJob.metadata?.name || '',
            namespace: cronJob.metadata?.namespace || namespace,
            schedule: cronJob.spec?.schedule || '',
            suspend: cronJob.spec?.suspend || false,
            active: cronJob.status?.active?.length || 0,
            lastSchedule: cronJob.status?.lastScheduleTime?.toISOString(),
            lastSuccessfulTime: cronJob.status?.lastSuccessfulTime?.toISOString(),
            age: calculateAge(cronJob.metadata?.creationTimestamp),
            labels: cronJob.metadata?.labels || {}
        };
    });
}
async function fetchCronJob(name, namespace, contextName) {
    try {
        const batchApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getBatchApi"])(contextName);
        const response = await batchApi.readNamespacedCronJob({
            name,
            namespace
        });
        const cronJob = response;
        return {
            name: cronJob.metadata?.name || '',
            namespace: cronJob.metadata?.namespace || namespace,
            schedule: cronJob.spec?.schedule || '',
            suspend: cronJob.spec?.suspend || false,
            active: cronJob.status?.active?.length || 0,
            lastSchedule: cronJob.status?.lastScheduleTime?.toISOString(),
            lastSuccessfulTime: cronJob.status?.lastSuccessfulTime?.toISOString(),
            age: calculateAge(cronJob.metadata?.creationTimestamp),
            labels: cronJob.metadata?.labels || {}
        };
    } catch (error) {
        console.error(`[K8s] Failed to fetch cronjob ${name}:`, error);
        return null;
    }
}
/**
 * Timeout wrapper for API calls
 */ function withTimeout(promise, timeoutMs = 10000) {
    return Promise.race([
        promise,
        new Promise((_, reject)=>setTimeout(()=>reject(new Error(`Request timeout after ${timeoutMs}ms`)), timeoutMs))
    ]);
}
async function fetchNamespaces(contextName) {
    try {
        const coreApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCoreApi"])(contextName);
        const response = await withTimeout(coreApi.listNamespace(), 10000);
        const namespaces = response.items;
        return namespaces.map((ns)=>{
            const phase = ns.status?.phase || 'Unknown';
            let status = 'Unknown';
            if (phase === 'Active') status = 'Active';
            else if (phase === 'Terminating') status = 'Terminating';
            return {
                name: ns.metadata?.name || '',
                status,
                age: calculateAge(ns.metadata?.creationTimestamp),
                labels: ns.metadata?.labels || {},
                annotations: ns.metadata?.annotations || {}
            };
        });
    } catch (error) {
        console.error('[K8s] Failed to fetch namespaces:', error);
        return [];
    }
}
async function fetchNamespace(name, contextName) {
    try {
        const coreApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCoreApi"])(contextName);
        const response = await coreApi.readNamespace({
            name
        });
        const ns = response;
        const phase = ns.status?.phase || 'Unknown';
        let status = 'Unknown';
        if (phase === 'Active') status = 'Active';
        else if (phase === 'Terminating') status = 'Terminating';
        return {
            name: ns.metadata?.name || '',
            status,
            age: calculateAge(ns.metadata?.creationTimestamp),
            labels: ns.metadata?.labels || {},
            annotations: ns.metadata?.annotations || {}
        };
    } catch (error) {
        console.error(`[K8s] Failed to fetch namespace ${name}:`, error);
        return null;
    }
}
async function fetchResourceQuotas(namespace, contextName) {
    try {
        const coreApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCoreApi"])(contextName);
        const response = await coreApi.listNamespacedResourceQuota({
            namespace
        });
        const quotas = response.items;
        return quotas.map((quota)=>({
                name: quota.metadata?.name || '',
                namespace: quota.metadata?.namespace || namespace,
                age: calculateAge(quota.metadata?.creationTimestamp),
                hard: quota.status?.hard || {},
                used: quota.status?.used || {},
                labels: quota.metadata?.labels || {}
            }));
    } catch (error) {
        // Silently return empty array for 403 (permission denied)
        // This is expected for users with namespace-scoped permissions
        if (error?.statusCode === 403 || error?.code === 403) {
            return [];
        }
        // Re-throw other errors to be handled by the API route
        throw error;
    }
}
async function fetchResourceQuota(name, namespace, contextName) {
    try {
        const coreApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCoreApi"])(contextName);
        const response = await coreApi.readNamespacedResourceQuota({
            name,
            namespace
        });
        const quota = response;
        return {
            name: quota.metadata?.name || '',
            namespace: quota.metadata?.namespace || namespace,
            age: calculateAge(quota.metadata?.creationTimestamp),
            hard: quota.status?.hard || {},
            used: quota.status?.used || {},
            labels: quota.metadata?.labels || {}
        };
    } catch (error) {
        console.error(`[K8s] Failed to fetch resource quota ${name}:`, error);
        return null;
    }
}
async function fetchLimitRanges(namespace, contextName) {
    try {
        const coreApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCoreApi"])(contextName);
        const response = await coreApi.listNamespacedLimitRange({
            namespace
        });
        const limitRanges = response.items;
        return limitRanges.map((lr)=>{
            const limits = (lr.spec?.limits || []).map((limit)=>({
                    type: limit.type || 'Container',
                    max: limit.max || undefined,
                    min: limit.min || undefined,
                    default: limit._default || undefined,
                    defaultRequest: limit.defaultRequest || undefined,
                    maxLimitRequestRatio: limit.maxLimitRequestRatio || undefined
                }));
            return {
                name: lr.metadata?.name || '',
                namespace: lr.metadata?.namespace || namespace,
                age: calculateAge(lr.metadata?.creationTimestamp),
                limits,
                labels: lr.metadata?.labels || {}
            };
        });
    } catch (error) {
        // Silently return empty array for 403 (permission denied)
        // This is expected for users with namespace-scoped permissions
        if (error?.statusCode === 403 || error?.code === 403) {
            return [];
        }
        // Re-throw other errors to be handled by the API route
        throw error;
    }
}
async function fetchLimitRange(name, namespace, contextName) {
    try {
        const coreApi = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$client$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getCoreApi"])(contextName);
        const response = await coreApi.readNamespacedLimitRange({
            name,
            namespace
        });
        const lr = response;
        const limits = (lr.spec?.limits || []).map((limit)=>({
                type: limit.type || 'Container',
                max: limit.max || undefined,
                min: limit.min || undefined,
                default: limit._default || undefined,
                defaultRequest: limit.defaultRequest || undefined,
                maxLimitRequestRatio: limit.maxLimitRequestRatio || undefined
            }));
        return {
            name: lr.metadata?.name || '',
            namespace: lr.metadata?.namespace || namespace,
            age: calculateAge(lr.metadata?.creationTimestamp),
            limits,
            labels: lr.metadata?.labels || {}
        };
    } catch (error) {
        console.error(`[K8s] Failed to fetch limit range ${name}:`, error);
        return null;
    }
}
async function fetchResourcesWithLabels(namespace, contextName) {
    try {
        const resources = [];
        // Fetch all resource types in parallel
        const [deployments, statefulsets, daemonsets, pods, services, configmaps, secrets, jobs, cronjobs, ingresses] = await Promise.all([
            fetchDeployments(namespace, contextName),
            fetchStatefulSets(namespace, contextName),
            fetchDaemonSets(namespace, contextName),
            fetchPods(namespace, contextName),
            fetchServices(namespace, contextName),
            fetchConfigMaps(namespace, contextName),
            fetchSecrets(namespace, contextName),
            fetchJobs(namespace, contextName),
            fetchCronJobs(namespace, contextName),
            fetchIngresses(namespace, contextName)
        ]);
        // Convert each resource type to ResourceWithLabels
        deployments.forEach((r)=>{
            resources.push({
                name: r.name,
                namespace: r.namespace,
                kind: 'Deployment',
                labels: r.labels,
                annotations: {}
            });
        });
        statefulsets.forEach((r)=>{
            resources.push({
                name: r.name,
                namespace: r.namespace,
                kind: 'StatefulSet',
                labels: r.labels,
                annotations: {}
            });
        });
        daemonsets.forEach((r)=>{
            resources.push({
                name: r.name,
                namespace: r.namespace,
                kind: 'DaemonSet',
                labels: r.labels,
                annotations: {}
            });
        });
        pods.forEach((r)=>{
            resources.push({
                name: r.name,
                namespace: r.namespace,
                kind: 'Pod',
                labels: r.labels,
                annotations: {}
            });
        });
        services.forEach((r)=>{
            resources.push({
                name: r.name,
                namespace: r.namespace,
                kind: 'Service',
                labels: r.labels,
                annotations: {}
            });
        });
        configmaps.forEach((r)=>{
            resources.push({
                name: r.name,
                namespace: r.namespace,
                kind: 'ConfigMap',
                labels: r.labels,
                annotations: {}
            });
        });
        secrets.forEach((r)=>{
            resources.push({
                name: r.name,
                namespace: r.namespace,
                kind: 'Secret',
                labels: r.labels,
                annotations: {}
            });
        });
        jobs.forEach((r)=>{
            resources.push({
                name: r.name,
                namespace: r.namespace,
                kind: 'Job',
                labels: r.labels,
                annotations: {}
            });
        });
        cronjobs.forEach((r)=>{
            resources.push({
                name: r.name,
                namespace: r.namespace,
                kind: 'CronJob',
                labels: r.labels,
                annotations: {}
            });
        });
        ingresses.forEach((r)=>{
            resources.push({
                name: r.name,
                namespace: r.namespace,
                kind: 'Ingress',
                labels: r.labels,
                annotations: {}
            });
        });
        return resources;
    } catch (error) {
        console.error(`[K8s] Failed to fetch resources with labels:`, error);
        return [];
    }
}
function indexLabels(resources) {
    const labelMap = new Map();
    // Index all labels
    resources.forEach((resource)=>{
        Object.entries(resource.labels).forEach(([key, value])=>{
            if (!labelMap.has(key)) {
                labelMap.set(key, new Map());
            }
            const valueMap = labelMap.get(key);
            if (!valueMap.has(value)) {
                valueMap.set(value, {
                    count: 0,
                    resourceTypes: new Set()
                });
            }
            const entry = valueMap.get(value);
            entry.count++;
            entry.resourceTypes.add(resource.kind);
        });
    });
    // Convert to LabelGroup array
    const labelGroups = [];
    labelMap.forEach((valueMap, key)=>{
        const values = [];
        let totalCount = 0;
        const resourceTypes = new Set();
        valueMap.forEach((entry, value)=>{
            values.push({
                value,
                count: entry.count
            });
            totalCount += entry.count;
            entry.resourceTypes.forEach((type)=>resourceTypes.add(type));
        });
        // Sort values by count descending
        values.sort((a, b)=>b.count - a.count);
        labelGroups.push({
            key,
            values,
            totalCount,
            resourceTypes: Array.from(resourceTypes)
        });
    });
    // Sort label groups by totalCount descending
    labelGroups.sort((a, b)=>b.totalCount - a.totalCount);
    return labelGroups;
}
function searchByLabelSelector(resources, selector) {
    if (!selector.trim()) {
        return resources;
    }
    // Parse selector (simple implementation for common cases)
    const selectors = selector.split(',').map((s)=>s.trim());
    return resources.filter((resource)=>{
        return selectors.every((sel)=>{
            // key=value
            if (sel.includes('=') && !sel.includes('!=')) {
                const [key, value] = sel.split('=').map((s)=>s.trim());
                return resource.labels[key] === value;
            }
            // key!=value
            if (sel.includes('!=')) {
                const [key, value] = sel.split('!=').map((s)=>s.trim());
                return resource.labels[key] !== value;
            }
            // !key (label not present)
            if (sel.startsWith('!')) {
                const key = sel.substring(1).trim();
                return !(key in resource.labels);
            }
            // key (label present)
            return sel in resource.labels;
        });
    });
}
}),
"[project]/lib/core/api-helpers.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "buildApiUrl",
    ()=>buildApiUrl,
    "getContextFromRequest",
    ()=>getContextFromRequest,
    "getNamespaceFromRequest",
    ()=>getNamespaceFromRequest,
    "handleK8sError",
    ()=>handleK8sError
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
;
function getNamespaceFromRequest(request) {
    const searchParams = request.nextUrl.searchParams;
    return searchParams.get('namespace') || '';
}
function getContextFromRequest(request) {
    const searchParams = request.nextUrl.searchParams;
    const context = searchParams.get('context');
    return context || undefined;
}
function buildApiUrl(path, namespace) {
    const url = new URL(path, ("TURBOPACK compile-time falsy", 0) ? "TURBOPACK unreachable" : 'http://localhost:3000');
    url.searchParams.set('namespace', namespace);
    return url.toString();
}
function handleK8sError(error, resourceType) {
    console.error(`[API] Failed to fetch ${resourceType}:`, error);
    // Check if it's an authorization error (401)
    if (error && typeof error === 'object' && 'code' in error) {
        if (error.code === 401) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Unauthorized',
                message: `You do not have permission to access ${resourceType} in this namespace`,
                code: 401
            }, {
                status: 401
            });
        }
        // Check if it's a forbidden error (403)
        if (error.code === 403) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Forbidden',
                message: `Access to ${resourceType} is forbidden`,
                code: 403
            }, {
                status: 403
            });
        }
    }
    // Generic error response
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
        error: `Failed to fetch ${resourceType}`
    }, {
        status: 500
    });
}
}),
"[project]/app/api/resourcequotas/route.ts [app-route] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GET",
    ()=>GET
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/server.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$api$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/k8s/api.ts [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$core$2f$api$2d$helpers$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/lib/core/api-helpers.ts [app-route] (ecmascript)");
;
;
;
async function GET(request) {
    try {
        const namespace = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$core$2f$api$2d$helpers$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getNamespaceFromRequest"])(request);
        const context = (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$core$2f$api$2d$helpers$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getContextFromRequest"])(request);
        if (!namespace) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json({
                error: 'Namespace parameter is required'
            }, {
                status: 400
            });
        }
        const quotas = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$k8s$2f$api$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["fetchResourceQuotas"])(namespace, context);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$server$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["NextResponse"].json(quotas);
    } catch (error) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$lib$2f$core$2f$api$2d$helpers$2e$ts__$5b$app$2d$route$5d$__$28$ecmascript$29$__["handleK8sError"])(error, 'ResourceQuotas');
    }
}
}),
];

//# sourceMappingURL=%5Broot-of-the-server%5D__4a33f050._.js.map