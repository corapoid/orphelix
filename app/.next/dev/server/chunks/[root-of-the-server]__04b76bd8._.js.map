{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 40, "column": 0}, "map": {"version":3,"sources":["file:///Users/dmakowski/git_priv/kubevista/app/lib/github/repo-analyzer.ts"],"sourcesContent":["/**\n * Repository Structure Analyzer\n *\n * Analyzes GitHub repository structure to detect:\n * - Kustomize usage (base/overlays pattern)\n * - Directory structure (flat, kustomize, helm)\n * - Naming patterns\n * - Namespaces\n */\n\nexport interface RepoStructure {\n  hasKustomize: boolean\n  structure: 'kustomize' | 'flat' | 'helm' | 'unknown'\n  baseDir: string | null\n  overlayDirs: string[]\n  namespaces: string[]\n  deploymentDirs: string[]\n  serviceDirs: string[]\n  commonPatterns: {\n    namePrefix?: string\n    nameSuffix?: string\n    hasEnvironments: boolean\n  }\n}\n\ninterface TreeItem {\n  name: string\n  path: string\n  type: 'file' | 'dir'\n}\n\n/**\n * Analyze repository structure\n */\nexport async function analyzeRepository(\n  owner: string,\n  repo: string,\n  branch: string,\n  mode?: 'demo',\n  baseUrl?: string\n): Promise<RepoStructure> {\n  const modeParam = mode === 'demo' ? '&mode=demo' : ''\n  const base = baseUrl || (typeof window !== 'undefined' ? '' : 'http://localhost:3000')\n\n  // Get root directory structure\n  const rootResponse = await fetch(\n    `${base}/api/github/tree?owner=${owner}&repo=${repo}&ref=${branch}&path=${modeParam}`\n  )\n\n  if (!rootResponse.ok) {\n    const error = await rootResponse.json().catch(() => ({ error: 'Unknown error' }))\n    throw new Error(error.error || `Failed to fetch repository structure: ${rootResponse.statusText}`)\n  }\n\n  const rootItems: TreeItem[] = await rootResponse.json()\n\n  // Initialize structure\n  const structure: RepoStructure = {\n    hasKustomize: false,\n    structure: 'unknown',\n    baseDir: null,\n    overlayDirs: [],\n    namespaces: [],\n    deploymentDirs: [],\n    serviceDirs: [],\n    commonPatterns: {\n      hasEnvironments: false,\n    },\n  }\n\n  // Look for k8s-related directories\n  const k8sDirs = rootItems.filter(item =>\n    item.type === 'dir' && (\n      item.name.toLowerCase().includes('k8s') ||\n      item.name.toLowerCase().includes('kubernetes') ||\n      item.name.toLowerCase().includes('manifests') ||\n      item.name.toLowerCase().includes('deploy')\n    )\n  )\n\n  // If no k8s dirs found, check root for YAML files\n  if (k8sDirs.length === 0) {\n    const hasYamlInRoot = rootItems.some(item =>\n      item.type === 'file' && (item.name.endsWith('.yaml') || item.name.endsWith('.yml'))\n    )\n\n    if (hasYamlInRoot) {\n      structure.structure = 'flat'\n      await analyzeDirectory('', rootItems, structure, owner, repo, branch, modeParam, base)\n      return structure\n    }\n\n    return structure // Unknown structure\n  }\n\n  // Analyze k8s directories\n  for (const k8sDir of k8sDirs) {\n    const dirResponse = await fetch(\n      `${base}/api/github/tree?owner=${owner}&repo=${repo}&ref=${branch}&path=${encodeURIComponent(k8sDir.path)}${modeParam}`\n    )\n\n    if (!dirResponse.ok) continue\n\n    const dirItems: TreeItem[] = await dirResponse.json()\n\n    // Check for Kustomize structure\n    const hasKustomization = dirItems.some(item =>\n      item.type === 'file' && (\n        item.name === 'kustomization.yaml' ||\n        item.name === 'kustomization.yml'\n      )\n    )\n\n    if (hasKustomization) {\n      structure.hasKustomize = true\n      structure.structure = 'kustomize'\n    }\n\n    // Look for base directory\n    const baseDir = dirItems.find(item =>\n      item.type === 'dir' && item.name === 'base'\n    )\n\n    if (baseDir) {\n      structure.baseDir = baseDir.path\n      structure.structure = 'kustomize'\n      structure.hasKustomize = true\n    }\n\n    // Look for overlays directory\n    const overlaysDir = dirItems.find(item =>\n      item.type === 'dir' && (item.name === 'overlays' || item.name === 'environments')\n    )\n\n    if (overlaysDir) {\n      const overlaysResponse = await fetch(\n        `${base}/api/github/tree?owner=${owner}&repo=${repo}&ref=${branch}&path=${encodeURIComponent(overlaysDir.path)}${modeParam}`\n      )\n\n      if (overlaysResponse.ok) {\n        const overlayItems: TreeItem[] = await overlaysResponse.json()\n        structure.overlayDirs = overlayItems\n          .filter(item => item.type === 'dir')\n          .map(item => item.path)\n\n        if (structure.overlayDirs.length > 0) {\n          structure.commonPatterns.hasEnvironments = true\n        }\n      }\n    }\n\n    // Analyze subdirectories\n    await analyzeDirectory(k8sDir.path, dirItems, structure, owner, repo, branch, modeParam, base)\n  }\n\n  // If we found Kustomize indicators but structure is still unknown, set it\n  if (structure.hasKustomize && structure.structure === 'unknown') {\n    structure.structure = 'kustomize'\n  }\n\n  // If no Kustomize but we have deployments/services dirs, it's flat structure\n  if (!structure.hasKustomize && (structure.deploymentDirs.length > 0 || structure.serviceDirs.length > 0)) {\n    structure.structure = 'flat'\n  }\n\n  return structure\n}\n\n/**\n * Analyze a directory and extract patterns\n */\nasync function analyzeDirectory(\n  _basePath: string,\n  items: TreeItem[],\n  structure: RepoStructure,\n  owner: string,\n  repo: string,\n  branch: string,\n  modeParam: string,\n  base: string\n): Promise<void> {\n  for (const item of items) {\n    if (item.type !== 'dir') continue\n\n    const dirName = item.name.toLowerCase()\n\n    // Check for deployment directories\n    if (dirName.includes('deployment') || dirName.includes('deploy')) {\n      structure.deploymentDirs.push(item.path)\n    }\n\n    // Check for service directories\n    if (dirName.includes('service') || dirName.includes('svc')) {\n      structure.serviceDirs.push(item.path)\n    }\n\n    // Check for namespace patterns (common namespace names)\n    const namespaceKeywords = ['namespace', 'ns', 'default', 'kube-system', 'kube-public']\n    if (namespaceKeywords.some(kw => dirName.includes(kw))) {\n      // Fetch YAML files in this directory\n      const nsResponse = await fetch(\n        `${base}/api/github/tree?owner=${owner}&repo=${repo}&ref=${branch}&path=${encodeURIComponent(item.path)}${modeParam}`\n      )\n\n      if (nsResponse.ok) {\n        const nsItems: TreeItem[] = await nsResponse.json()\n        const yamlFiles = nsItems.filter(f =>\n          f.type === 'file' && (f.name.endsWith('.yaml') || f.name.endsWith('.yml'))\n        )\n\n        // Extract namespace names from YAML filenames\n        for (const file of yamlFiles) {\n          const match = file.name.match(/^([a-z0-9-]+)\\.ya?ml$/i)\n          if (match && !structure.namespaces.includes(match[1])) {\n            structure.namespaces.push(match[1])\n          }\n        }\n      }\n    }\n  }\n\n  // Detect common naming patterns\n  const allFileNames = items\n    .filter(item => item.type === 'file' && (item.name.endsWith('.yaml') || item.name.endsWith('.yml')))\n    .map(item => item.name.replace(/\\.ya?ml$/i, ''))\n\n  if (allFileNames.length > 2) {\n    // Look for common prefix\n    const commonPrefix = findCommonPrefix(allFileNames)\n    if (commonPrefix && commonPrefix.length > 2) {\n      structure.commonPatterns.namePrefix = commonPrefix\n    }\n\n    // Look for common suffix\n    const commonSuffix = findCommonSuffix(allFileNames)\n    if (commonSuffix && commonSuffix.length > 2) {\n      structure.commonPatterns.nameSuffix = commonSuffix\n    }\n  }\n}\n\n/**\n * Find common prefix in array of strings\n */\nfunction findCommonPrefix(strings: string[]): string | null {\n  if (strings.length === 0) return null\n\n  let prefix = strings[0]\n\n  for (let i = 1; i < strings.length; i++) {\n    while (strings[i].indexOf(prefix) !== 0) {\n      prefix = prefix.substring(0, prefix.length - 1)\n      if (prefix === '') return null\n    }\n  }\n\n  // Remove trailing dashes/underscores\n  return prefix.replace(/[-_]+$/, '')\n}\n\n/**\n * Find common suffix in array of strings\n */\nfunction findCommonSuffix(strings: string[]): string | null {\n  if (strings.length === 0) return null\n\n  const reversed = strings.map(s => s.split('').reverse().join(''))\n  const prefix = findCommonPrefix(reversed)\n\n  if (!prefix) return null\n\n  return prefix.split('').reverse().join('').replace(/^[-_]+/, '')\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 213, "column": 0}, "map": {"version":3,"sources":["file:///Users/dmakowski/git_priv/kubevista/app/app/api/github/analyze-structure/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\nimport { analyzeRepository } from '@/lib/github/repo-analyzer'\n\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url)\n    const owner = searchParams.get('owner')\n    const repo = searchParams.get('repo')\n    const ref = searchParams.get('ref') || 'main'\n    const mode = searchParams.get('mode')\n\n    if (!owner || !repo) {\n      return NextResponse.json(\n        { error: 'owner and repo are required' },\n        { status: 400 }\n      )\n    }\n\n    // Get base URL for server-side fetch\n    const protocol = request.headers.get('x-forwarded-proto') || 'http'\n    const host = request.headers.get('host') || 'localhost:3000'\n    const baseUrl = `${protocol}://${host}`\n\n    const structure = await analyzeRepository(\n      owner,\n      repo,\n      ref,\n      mode === 'demo' ? 'demo' : undefined,\n      baseUrl\n    )\n\n    return NextResponse.json(structure)\n  } catch (error) {\n    console.error('Failed to analyze repository structure:', error)\n    return NextResponse.json(\n      { error: error instanceof Error ? error.message : 'Failed to analyze repository structure' },\n      { status: 500 }\n    )\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;QAC5C,MAAM,QAAQ,aAAa,GAAG,CAAC;QAC/B,MAAM,OAAO,aAAa,GAAG,CAAC;QAC9B,MAAM,MAAM,aAAa,GAAG,CAAC,UAAU;QACvC,MAAM,OAAO,aAAa,GAAG,CAAC;QAE9B,IAAI,CAAC,SAAS,CAAC,MAAM;YACnB,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA8B,GACvC;gBAAE,QAAQ;YAAI;QAElB;QAEA,qCAAqC;QACrC,MAAM,WAAW,QAAQ,OAAO,CAAC,GAAG,CAAC,wBAAwB;QAC7D,MAAM,OAAO,QAAQ,OAAO,CAAC,GAAG,CAAC,WAAW;QAC5C,MAAM,UAAU,GAAG,SAAS,GAAG,EAAE,MAAM;QAEvC,MAAM,YAAY,MAAM,IAAA,+JAAiB,EACvC,OACA,MACA,KACA,SAAS,SAAS,SAAS,WAC3B;QAGF,OAAO,gJAAY,CAAC,IAAI,CAAC;IAC3B,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,2CAA2C;QACzD,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAAyC,GAC3F;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}